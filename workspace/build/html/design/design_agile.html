
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5. 애자일 &#8212; Code Accelerator Document 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="next" title="6. Reactive X" href="design_reactivex.html" />
    <link rel="prev" title="4. 소프트웨어 설계 문제" href="design_problem.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-136789982-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-136789982-1');
</script>


  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="design-pattern">
<span id="id1"></span><h1>5. 애자일<a class="headerlink" href="#design-pattern" title="제목 주소">¶</a></h1>
<div class="section" id="id2">
<h2>5.1. 기존의 방법론<a class="headerlink" href="#id2" title="제목 주소">¶</a></h2>
<p>전통적인 프로젝트 방법론에는 여러가지 문제점이 가지고 있다.</p>
<p>요구사항은 수시로 변경되지만 기존 프로젝트 방법론에서는 대응할 수 있는 방법이 없다. 개발자들은 공들여 만든 설계도 그대로 구현을 하지만, 얼마 가지않아 고객은 새로운 기능을 요구하고 기존의 설계가 쓸모 없어 지게된다. 아마 고객은 동작하는 소프트웨어를 보게 되면서 자신이 원하는 것을 더 정확하게 알게된다.</p>
<p>결국 설계를 다시하게 되고 개발자는 모든 엣지 케이스를 다룰 수 있는 설계를 하기 위해 다시 시간에 쫒기게 된다. 결국 프로젝트를 제시간에 끝낼 수 없게 된다.</p>
<p><strong>개발자는 요구사항 변경한 고객을 원망한다. 그리고 매니저는 다음 프로젝트 실패하지 않기 전보다 더 복잡하고 엄격한 설계 문서와 프로세스를 요구한다.</strong>
그리고 추가된 문서나 프로세스 때문에 프로젝트 기간은 더 늘어지고, 요구사항 변경때마다 설계 변경과 함께 많은 자료를 수정하게 된다. 결국 개발자의 반은 설계를 문서를 업데이트 하고 있고, 반은 밤새 코드를 작성한다.</p>
<p>악순환의 끝에 개발자는 점점 단위 테스트나 인수 테스트를 당장 쓸모 없는 것으로 보고 작성하거나 실행하지 않는다. 결국 완성된 시스템은 많은 결함을 가질 수 있으며, 결합도가 매우 높아서 사후 테스트 거의 불가능하고 유지보수하기 어려울 것이다.</p>
<p>코드를 작성하면서 설계를 고려한다면 매우 유연하고 변경 가능한 코드를 만들 수 있다. 다른말로 얘기하면 코드를 작성하는 매 순간마다 설계는 변경되며, 지속적 통합에 따라 신뢰할 수 있는 설계 및 소프트웨어가 완성되는 것이다. <strong>애자일은 요구사항 변경에 민첩하게 반응할 수 있으며, 최소의 비용으로 최대의 효율을 내는 방법론 중 하나이다.</strong></p>
<p>아래는 기본적인 애자일 아이디어이다. <a class="reference external" href="https://agilemanifesto.org">애자일 선언문</a> 을 참고하면 더 좋다.</p>
<ul class="simple">
<li>프로세스와 툴보다 개인과 상호작용이 우선이다.</li>
<li>포괄적인 문서보다 동작하는 소프트웨어가 우선이다.</li>
<li>계약 협상보다 고객 협력이 우선이다.</li>
<li>계획을 따르는 것보다 변화에 대한 반응이 우선이다.</li>
</ul>
<p>선언문에 따르면 오른쪽의 행위도 중요하지만 왼쪽의 행위가 더 가치있다고 한다.</p>
<p>Agile에는 여러가지 방법론이나 프레임워크가 존재한다. (XP, Scrum 등)
이러한 방법론 이해를 위해 실제 Agile 프로젝트 관리 시스템이 어떻게 동작하는지 보면 좋은데, <a class="reference external" href="https://bcho.tistory.com/826">조대협님의 Scrum 프로젝트 관리</a> 가 잘 정리된 포스트중 하나이다.</p>
</div>
<div class="section" id="extreme-programming-xp">
<h2>5.2. Extreme programming(익스트림 프로그래밍, XP)<a class="headerlink" href="#extreme-programming-xp" title="제목 주소">¶</a></h2>
<p><strong>Extreme programming은 실천가능한 이상적인 방법으로 고객으로부터 최대의 요구사항을 얻어내며, 잦은 요구사항 변경이 프로젝트 전체에 영향을 주지 않도록 하는 유연한 모델이다. 반복적이고 점층적인 방식으로 소프트웨어를 개발하는 방법론이다.</strong></p>
<p>XP는 Agile 방법 중에서 가장 유명한 실천 방법이다.
요구사항 분석단계에서 사용자 스토리로 고객 요구사항을 정리하고, 반복 계획 및 릴리스 계획을 세워 프로젝트를 진행한다.
실제 반복을 진행하기 전에 <em>스파이크를</em> 진행한다. 스파이크란 프로젝트 초기에 스토리를 진행하기 앞서 사용할 기술(라이브러리, 프레임워크)을 조사하고, 요구사항에 관련된 배경지식을 습득하는 단계이다.
스파이크를 통해 앞으로 진행할 스토리의 속도를 쉽게 추측할 수 있다.</p>
<div class="section" id="id4">
<h3>5.2.1. 사용자 스토리<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p><strong>사용자 스토리는 사용자나 고객에게 가치를 주는 기능을 기록한 것이다.</strong></p>
<p>사용자 스토리는 3가지로 구성된다. <strong>CCW라는 약어를 붙일 수 있다.</strong></p>
<ul class="simple">
<li>서술(Written Description): 서술 형태로 카드에 작성되며, 계획하거나 대화를 이어나가기 위해 사용된다.</li>
<li>대화(Conversation): 대화를 통해 세부사항을 구체화한다.</li>
<li>인수 테스트(Confirmation, 확인): 테스트를 통해 구체적인 부분을 문서화하며, 스토리의 완료 여부를 판단한다.</li>
</ul>
<p>장점은 다음과 같다.</p>
<ul class="simple">
<li>문서보다 구두 의사소통을 강조한다.</li>
<li>사용자와 개발자 모두가 이해할 수 있다.</li>
<li>계획 수립에 적당한 단위이다.</li>
<li>반복적 개발에 효과적으로 사용된다.</li>
<li>스토리를 크게 유지함으로써, 세부사항이 필요할때 까지 뒤로 미룰 수 있다. (전체적인 윤곽을 잡을 수 있다)</li>
</ul>
<p>사용자 스토리의 세부사항은 인수테스트나 <strong>주석을</strong> 통해 작성할 수 있으며, 완료되었는지는 인수테스트를 실행해 보면서 알 수 있다.
<strong>주석에</strong> 세부사항을 담는 것 보다는, <strong>해결된 쟁점 또는 고객과 대화를 계속 이을 수 있도록 하는 키워드를</strong> 쓰는 것을 권장한다.</p>
<p><strong>사용자 스토리 수집은 물고기를 그물질하는 것과 유사하다.</strong> 처음에는 성긴 그물을 이용해서 큰 물고기 부터 잡으며, 이후에는 더 촘촘한 그물을 이용해서 물고기를 잡을 수 있다.
마찬가지로 사용자 스토리도 처음엔 큰 목적 스토리를 수집하고, 나중에는 고객과의 대화를 통해 목적 스토리를 여러개의 닫힌 스토리로 나눈다.
<strong>그리고 스토리를 수집하는 매 순간에는 어떤 사용자가 어떤 행위를 하는지 수집해야 한다.</strong></p>
<p><strong>구체적으로 스토리를 수집하는 방법에는 사용자 인터뷰, 스토리 작성 워크샵이 있다.</strong>
먼저 스토리 작성 워크샵에는 먼저 고수준의 컴포넌트간 상호작용하는 프로토타입(충실도 낮은 프로토타입)을 그리고, 그것을 기반으로 고객에 여러 상황에서 어떻게 동작을 행동할지 브레인스토밍한다.
또한 점점 프로토타입을 개선해나간다.
그리고 사용자 스토리 목록을 도출해낸다. 개발자는 스토리 수집에 도움을 줄 수 있지만, 작성된 내용의 책임은 고객에게 있다.</p>
<p><strong>다른 수집 방법은 워크샵을 열고 사용자 역할이나 등장인물을 하나씩 선택하여</strong> 관련된 스토리를 작성하는 것이다.</p>
<div class="section" id="id5">
<h4>5.2.1.1. 스토리의 종류<a class="headerlink" href="#id5" title="제목 주소">¶</a></h4>
<p><strong>사용자 스토리는 추상적인 것과 구체적인 것을 다 표현할 수 있다.</strong></p>
<ul class="simple">
<li>목적(Epic) 스토리 (다른 스토리를 작성하는데 도움이 되는 큰 스토리)</li>
<li>닫힌 스토리 (테스트로 완료될 수 있는 스토리, 상세한 스토리와는 다름)</li>
<li>제약사항 스토리 (구현될 수 없으며 규칙처럼 지켜야 하는 스토리, 스토리 점수가 없고 반복에 포함되지 않는 스토리)</li>
</ul>
<p>위 스토리를 상황에 따라 적절히 사용하면 된다.</p>
<ul class="simple">
<li><strong>일반적으로 프로젝트가 큰 경우 먼저 목적 스토리를 작성하고, 스토리가 선택되어 반복이 시작될때 고객과 함께 적당한 크기의 스토리로 분할한다.</strong></li>
<li><em>《예전 DB를 그대로 사용해야 한다》</em> 가 하나의 제약사항 스토리 라면, 하단에 제약사항이라고 표기하여 제약사항 사용자 스토리임을 나타낼 수 있다.</li>
</ul>
</div>
<div class="section" id="id6">
<h4>5.2.1.2. 전통적인 방식<a class="headerlink" href="#id6" title="제목 주소">¶</a></h4>
<p>전통적인 요구사항 작성법에는 한계가 있다.</p>
<ol class="arabic simple">
<li>요구사항 분석은 개발자 입장에서 재해석 된 것이며, 문장은 불완전 요소를 많이 포함한다. 개발자는 이를 잘못 해석할 수 있다.</li>
<li><strong>고객은 프로젝트가 진행되고 동작하는 소프트웨어를 보고 고객은 더 많은 것을 배우게되고, 고객 자신이 원하는 것을 더 구체적으로 알 수 있게 된다.</strong> 또 어떤 고객은 개발자에게 자신이 요청했던 시스템이라는 것을 인정하면서도 원했던 것은 아닌거 같다라고 말을 하기도 한다.</li>
</ol>
<p>예를들어 <strong>천재적인 분석가가 모든 요구사항을 파악(불가능한 일)했다고 하자. 그리고 실제 개발하면서 필요한 모든 세부 사항을 개발했다고 하자. 하지만 결국 고객의 요구사항은 변경되며 모든 것을 원점에서 시작해야한다.</strong></p>
<p><strong>반면 사용자 스토리는 대화를 통해 고객과 개발자는 즉각적인 상호 피드백을 받을 수 있으며, 서로 요구사항 이해와 학습을 할 수 있게 도와준다.</strong></p>
</div>
</div>
<div class="section" id="id7">
<h3>5.2.2. 릴리즈 계획<a class="headerlink" href="#id7" title="제목 주소">¶</a></h3>
<p>릴리즈는 주요 기능들을 포함한 제품을 고객에게 공개하는 것을 뜻한다. <strong>개발자는 고객과 함께 수집된 스토리를 살펴보면서</strong> 대략적인 스토리 점수를 추정하는 작업을 한다.
<strong>큰 스토리는 작은 스토리로 스토리를 나눌 수 있다.</strong> 그리고 난 뒤, <strong>고객은 스토리의 우선순위를 결정해야한다.</strong>
기본적으로 개발자는 고객에게 스토리의 크기를 알려야 하고, 아키텍처 관련된 스토리의 우선순위를 높이도록 노력해야 한다.(JIRA에서는 Chore 타입으로 분리되는 듯)
하지만 충돌할 경우 고객의 우선순위를 더 우선시한다.</p>
<p><strong>우선순위를 부여하기 어려운 경우 스토리를 나눌 필요가 있을 수도 있다.</strong> 그리고 우선순위를 기반으로 어떤 스토리를 릴리즈에 포함시킬지 결정해야 하며, 추정된 스토리 점수의 합과 팀의 속도를 기반으로 몇번의 반복에서 릴리즈가 될 수 있는지 계산해본다. <strong>이미 릴리즈 날짜가 결정되어 있다면 어떤 스토리를 포기하거나 더 할지 고려해야 한다.</strong>
고객은 솔직하게 마감일을 설정해야 하며 버퍼를 두어서는 안된다. 가령 릴리즈 안정을 위해 1달 일찍 릴리즈를 당기는 것은 허용되지 않는다.</p>
<p><strong>마지막으로 결정된 스토리를 각 반복에 우선순위대로 할당해야한다.</strong></p>
</div>
<div class="section" id="id8">
<h3>5.2.3. 반복 계획<a class="headerlink" href="#id8" title="제목 주소">¶</a></h3>
<p>큰 스토리가 포함되어 있다면 큰 스토리를 일정을 수립할 수 있을 정도로 작고, 완료 가능한 닫힌 스토리로 쪼갠다. 고객과 대화를 통해 <strong>스토리를 분석하고 스토리를 태스크로 나누고 각 개발자는 태스크를 가져간다.</strong></p>
</div>
<div class="section" id="id9">
<h3>5.2.4. 빠른설계<a class="headerlink" href="#id9" title="제목 주소">¶</a></h3>
<p>각 반복 시작 후 일반적으로 <strong>빠른 설계 회의(quick design session)를 갖게된다.</strong>
설계의 산출물이 정해진것은 아니며, 선택된 스토리를 정확하게 분석하고 여러가지 스케치를 통해 숨어있는 추상화를 꺼내는 작업을 한다. 분석 단계에서 <strong>사용할 수 있는 도구는</strong> 다음과 같다.
<strong>가장 중요한 것은 각 도구의 산출물을 기반으로 코드 설계를 시작하는 것이다.</strong></p>
<ul class="simple">
<li><strong>사용자 스토리</strong> (반복에서 반드시 구현 해야할 것) 및 <strong>인수 테스트</strong> (고객의 요구사항을 이해하는데 도움이되며, 스토리 작성 전이나 반복 중에 작성)</li>
<li><strong>유즈 케이스</strong> (상세화된 스토리, 다이어그램 포함, out of date)</li>
<li>도메인 모델링 (out of date)</li>
<li>인터페이스 스케치 (out of date)</li>
<li>클래스 다이어그램 (out of date)</li>
<li>시퀀스 다이어그램 (out of date)</li>
<li>테스트 코드(TDD) (up to date)</li>
<li><strong>작업 계획 세우기</strong></li>
<li>ERD 작성 (out of date, 꼭 DB가 필요한 시점에 DB설계를 시작해야 함)</li>
</ul>
</div>
<div class="section" id="id10">
<h3>5.2.5. 반복<a class="headerlink" href="#id10" title="제목 주소">¶</a></h3>
<p>반복이 끝날때 쯤 <strong>사용자 인수 테스트(Acceptance test)를 수행하여 스토리가 완성되었는지 확인한다.</strong> 그리고 사용자 피드백을 기반으로 필요하면 새로운 스토리를 만든다.</p>
</div>
<div class="section" id="tdd">
<h3>5.2.6. TDD<a class="headerlink" href="#tdd" title="제목 주소">¶</a></h3>
<p>TDD는 기본적으로 개발자의 코드를 검증할 수 있으므로 개발자에게 가치 있는 작업이 된다.
테스트 없이 원하는 프로그램이 잘 동작하는지 알 수 없다. <strong>또한 호출자의 관점에서 프로그램의 인터페이스에 관심을 갖게 하여 코드 설계를 고민하도록 만든다.</strong> <strong>또한 실행가능한 문서의 한 형태로 남을 수 있으며,</strong> 항상 최신의 튜토리얼이 된다. <strong>하나의 산출물이 다양한 목적으로 사용되므로 효율적이다.</strong>
그 외에도 강제로 주변 환경과 분리된 테스트 가능한 프로그램을 만들 수 있게 하는 효과가 있다.</p>
<div class="section" id="id11">
<h4>5.2.6.1. 전통적인 방식<a class="headerlink" href="#id11" title="제목 주소">¶</a></h4>
<p>구체적으로 전체적인 설계를 한 뒤 코딩하는 것은 여러가지 설계 사항이 고려되지 않고 성급하게 특정 방식에 초점이 맞춰진 채로 진행될 가능성이 높다.</p>
</div>
</div>
<div class="section" id="id12">
<h3>5.2.7. 반복 계획의 가치<a class="headerlink" href="#id12" title="제목 주소">¶</a></h3>
<ul class="simple">
<li>반복이 진행될 수록 고객은 더 구체적이고 정확한 것을 말할 수 있게 된다.</li>
<li>고객은 반복에서 얻은 지식을 바탕으로 더 자세한 아이디어를 갖게 되고, 프로젝트를 이끌어 나간다.</li>
<li>개발자 역시 프로젝트 초반에 비해 도메인에 대한 지식이 많이 쌓이게 되므로, 더 완벽한 분석, 설계, 구현을 할 수 있다.</li>
<li>반복계획을 사용하면 고객이 원하는 것 부터 순서대로 구현할 수 있음</li>
<li>팀의 퍼포먼스를 측정하여 프로젝트 예상 소요 기간과 비용을 측정할 수 있다.</li>
<li>각 반복의 끝에 시연을 하고 고객으로부터 피드백을 받을 수 있다.</li>
</ul>
</div>
<div class="section" id="id13">
<h3>5.2.8. 반복 계획과 점진적 설계<a class="headerlink" href="#id13" title="제목 주소">¶</a></h3>
<p>스토리 단위로 설계, 구현을 반복하는 것은 어떤 가치를 줄까? 이전 방식에 비해 어떤 점이 나을까? 처음부터 전체 설계를 하는 것은 몇가지 위험성을 갖고 있다. <strong>고객은 프로젝트가 진행되는 중간에 새로운 요구사항을 전달하거나 기존의 요구사항을 변경한다. 이는 부정하고 싶어도 부정할 수 없다.</strong> 일단 요구사항이 바뀌면 전체 설계는 틀어지게 된다. 어떤 개발자는 재사용을 위한 설계를 하려고 한다. 이는 지나치게 추상적인 프레임워크가 되거나, 또는 재사용이 불가능하게 된다.</p>
<p>또한 설계를 한번에 끝내는 것은 쉽지 않다. 설계에 참여한 개발자들은 구현이 어려운 많은 에지 케이스를 생각하고 있기 때문이다. 프로젝트의 시작에 운좋게 좋은 설계를 얻었다고 하더라도 <strong>요구사항이 변경된다.</strong> <strong>애자실 설계 원칙을 포함한 XP 방법론과 점진적 설계를 활용하면 이러한 어려움을 해결할 수 있다.</strong></p>
<p><strong>반복 계획이 적용될 경우 사용자의 변경 요구사항을 수용할 수 있을 정도로 유연하다.</strong></p>
</div>
</div>
<div class="section" id="id14">
<h2>5.3. 참조<a class="headerlink" href="#id14" title="제목 주소">¶</a></h2>
<ul class="simple">
<li>use case: <a class="reference external" href="https://martinfowler.com/bliki/UseCasesAndStories.html">https://martinfowler.com/bliki/UseCasesAndStories.html</a></li>
<li>agile 설계: <a class="reference external" href="http://agilemodeling.com/essays/agileDesign.htm">http://agilemodeling.com/essays/agileDesign.htm</a></li>
<li>agile 분석: <a class="reference external" href="http://agilemodeling.com/essays/iterationModeling.htm">http://agilemodeling.com/essays/iterationModeling.htm</a></li>
<li>구체적인 설계: <a class="reference external" href="http://agilemodeling.com/essays/modelStorming.htm">http://agilemodeling.com/essays/modelStorming.htm</a></li>
<li>tdd: <a class="reference external" href="http://agiledata.org/essays/tdd.html">http://agiledata.org/essays/tdd.html</a></li>
<li>jira agile: <a class="reference external" href="https://community.atlassian.com/t5/Jira-Core-questions/epic-vs-story-vs-task/qaq-p/204224">https://community.atlassian.com/t5/Jira-Core-questions/epic-vs-story-vs-task/qaq-p/204224</a></li>
<li>spike: <a class="reference external" href="https://www.scaledagileframework.com/spikes/">https://www.scaledagileframework.com/spikes/</a></li>
<li>jira 설명 : <a class="reference external" href="https://bcho.tistory.com/826">https://bcho.tistory.com/826</a></li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Code Accelerator Document</a></h1>








<h3>탐색</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../author.html">관리자 (Author)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../java/java_index.html">자바(Java)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="design_index.html">설계(Design)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="design_terms.html">1. 용어</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_pattern.html">2. 디자인 패턴</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_rest.html">3. Rest API</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_problem.html">4. 소프트웨어 설계 문제</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5. 애자일</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_reactivex.html">6. Reactive X</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../scala/scala_index.html">스칼라(Scala)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pr_language/language_index.html">프로그래밍 언어(Programming Language)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css/css_index.html">CSS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_index.html">서버(Server)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux/linux_index.html">리눅스</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spring/spring_index.html">Spring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../network/network_index.html">네트워크</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript/javascript_index.html">Javascript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netframework/netframework_index.html">.Net Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/python_index.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../database/database_index.html">데이터베이스</a></li>
<li class="toctree-l1"><a class="reference internal" href="../os/operating_system_index.html">운영체제</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datastructure/datastructure_index.html">알고리즘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../statistics/statistics_index.html">통계학(Statictics)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/security_index.html">보안(Security)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ict/ict_index.html">ICT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../etc/etc_index.html">달리 분류되지 않음</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="design_index.html">설계(Design)</a><ul>
      <li>Previous: <a href="design_problem.html" title="이전 장">4. 소프트웨어 설계 문제</a></li>
      <li>Next: <a href="design_reactivex.html" title="다음 장">6. Reactive X</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="바로 가기" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
      &copy;2017, Choe Changwon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/design/design_agile.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    


  </body>
</html>