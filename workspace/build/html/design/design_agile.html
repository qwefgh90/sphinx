
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5. 애자일 &#8212; Code Accelerator Document 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="next" title="스칼라(Scala)" href="../scala/scala_index.html" />
    <link rel="prev" title="4. 소프트웨어 설계 문제" href="design_problem.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="design-pattern">
<span id="id1"></span><h1>5. 애자일<a class="headerlink" href="#design-pattern" title="제목 주소">¶</a></h1>
<div class="section" id="id2">
<h2>5.1. 기존의 방법론<a class="headerlink" href="#id2" title="제목 주소">¶</a></h2>
<p>전통적인 프로젝트 방법론에는 여러가지 문제점이 가지고 있다.</p>
<p>요구사항은 수시로 변경되지만 기존 프로젝트 방법론에서는 대응할 수 있는 방법이 없다. 개발자들은 공들여 만든 설계도 그대로 구현을 하지만, 얼마 가지않아 고객은 새로운 기능을 요구하고 기존의 설계가 쓸모 없어 지게된다. 결국 설계를 다시하게 되고 개발자는 모든 엣지 케이스를 다룰 수 있는 설계를 하기 위해 다시 시간에 쫒기게 된다. 결국 프로젝트를 제시간에 끝낼 수 없게 된다.</p>
<p>개발자는 요구사항 변경을 실패의 원인으로 보고 고객을 원망한다. 그리고 다음 프로젝트를 진행할 때는 실패하지 않기 전보다 더 복잡하고 엄격한 설계 문서와 프로세스를 요구한다. 그리고 추가된 문서나 프로세스 때문에 프로젝트 기간은 더 늘어지고, 요구사항 변경때마다 설계를 다시하게 된다. 결국 개발자는 밤새 구현에만 집중하게 되고, 또한 여러가지 테스트나 검증을 당장 쓸모 없는 것으로 본다. 결국 실패하거나 완성되더라도 결합도가 매우 높으며 유지보수하기 힘든 코드가 나오게 된다.</p>
<p>코드를 작성하기 전에 모든 문제를 고려한 큰 설계에 초점을 맞춘다면 유연한 설계를 얻을 수 없다. 결국 변경이나 재사용에 취약한 코드가 나오게 된다.</p>
<p>코드를 작성하면서 설계를 고려한다면 매우 유연하고 변경 가능한 코드를 만들 수 있다. 다른말로 얘기하면 코드를 작성하는 매 순간마다 설계는 변경되며, 지속적 통합에 따라 신뢰할 수 있는 설계 및 소프트웨어가 완성되는 것이다. <strong>애자일은 요구사항 변경에 민첩하게 반응할 수 있으며, 최소의 비용으로 최대의 효율을 내는 방법론 중 하나이다.</strong></p>
<p>아래는 기본적인 애자일 아이디어이다.</p>
<ul class="simple">
<li>프로세스와 툴보다 개인과 상호작용이 우선이다.</li>
<li>포괄적인 문서보다 동작하는 소프트웨어가 우선이다.</li>
<li>계약 협상보다 고객 협력이 우선이다.</li>
<li>계획을 따르는 것보다 변화에 대한 반응이 우선이다.</li>
</ul>
</div>
<div class="section" id="extreme-programming-xp">
<h2>5.2. Extreme programming(익스트림 프로그래밍, XP)<a class="headerlink" href="#extreme-programming-xp" title="제목 주소">¶</a></h2>
<p>XP는 Agile 방법 중에서 가장 유명한 실천 방법이다.</p>
<p>요구사항 분석단계에서 사용자 스토리로 고객 요구사항을 정리하고, 반복 계획 및 릴리스 계획을 세워 프로젝트를 진행한다.</p>
<p>실제 반복을 진행하기 전에 <em>스파이크를</em> 진행한다. 스파이크란 프로젝트 초기에 한 두개의 스토리로 개발자의 속도를 추측하기 위한 단계이다.</p>
<div class="section" id="id3">
<h3>5.2.1. 반복계획<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>주로 팀의 속도와 각 스토리의 사업적 가치를 기반으로 스토리들을 어떤 반복에서 완료할지 계획하는 것이다.</p>
<p>각 반복 계획에서는 일반적으로 <strong>빠른 설계 회의(quick design session)를 갖게된다.</strong> 설계의 산출물이 정해진것은 아니며, 선택된 스토리를 정확하게 분석하고 여러가지 스케치를 통해 숨어있는 추상화를 꺼내는 작업을 한다.</p>
<p>분석 단계에서 <strong>사용할 수 있는 도구는</strong> 다음과 같다. <strong>가장 중요한 것은 각 도구의 산출물을 기반으로 코드 설계를 시작하는 것이다.</strong></p>
<ul class="simple">
<li><strong>사용자 스토리</strong> (반복에서 반드시 구현 해야할 것) 및 <strong>인수 테스트</strong> (큰 수준의 설계를 얻을 수 있으며, 설계가 진행되기전에 하는것이 좋음)</li>
<li><strong>유즈 케이스</strong> (상세화된 스토리, 다이어그램 포함, out of date)</li>
<li>도메인 모델링 (out of date)</li>
<li>인터페이스 스케치 (out of date)</li>
<li>클래스 다이어그램 (out of date)</li>
<li>시퀀스 다이어그램 (out of date)</li>
<li>테스트 코드(TDD) (up to date)</li>
<li><strong>작업 계획 세우기</strong></li>
<li>ERD 작성 (out of date, 꼭 DB가 필요한 시점에 DB설계를 시작해야 함)</li>
</ul>
<p>반복이 끝날때 쯤 사용자 인수 테스트(Acceptance test)를 수행하고 통과하지 못할 경우 관련된 새로운 스토리를 만든다.</p>
</div>
<div class="section" id="tdd">
<h3>5.2.2. TDD<a class="headerlink" href="#tdd" title="제목 주소">¶</a></h3>
<p><strong>TDD는 기본적으로 개발자의 코드를 검증할 수 있으므로 개발자에게 가치 있는 작업이 된다. 더 중요한 것은 호출자의 관점에서 프로그램의 인터페이스에 관심을 갖게 하는 것이다.</strong> <strong>또한 실행가능한 문서의 한 형태로 남을 수 있으며,</strong> 항상 최신의 튜토리얼이 된다. <strong>하나의 산출물이 다양한 목적으로 사용되므로 효율적이다.</strong> 그 외에도 강제로 주변 환경과 분리된 테스트 가능한 프로그램을 만들 수 있게 하는 효과가 있다.</p>
<p>구체적으로 전체적인 설계를 한 뒤 코딩하는 것은 여러가지 설계 사항이 고려되지 않고 성급하게 초점이 맞춰진 채로 진행될 가능성이 높다.</p>
</div>
<div class="section" id="id4">
<h3>5.2.3. 반복 계획의 가치<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<ul class="simple">
<li>반복이 진행될 수록 고객은 더 구체적이고 정확한 것을 말할 수 있게 된다.</li>
<li>고객은 반복에서 얻은 지식을 바탕으로 더 자세한 아이디어를 갖게 되고, 프로젝트를 이끌어 나간다.</li>
<li>개발자 역시 프로젝트 초반에 비해 도메인에 대한 지식이 많이 쌓이게 되므로, 더 완벽한 분석, 설계, 구현을 할 수 있다.</li>
<li>반복계획을 사용하면 고객이 원하는 것 부터 순서대로 구현할 수 있음</li>
<li>팀의 퍼포먼스를 측정하여 프로젝트 예상 소요 기간과 비용을 측정할 수 있다.</li>
<li>각 반복의 끝에 시연을 하고 고객으로부터 피드백을 받을 수 있다.</li>
</ul>
</div>
<div class="section" id="id5">
<h3>5.2.4. 반복 계획과 점진적 설계<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<p>스토리 단위로 설계, 구현을 반복하는 것은 어떤 가치를 줄까? 이전 방식에 비해 어떤 점이 나을까? 처음부터 전체 설계를 하는 것은 몇가지 위험성을 갖고 있다. 고객은 프로젝트가 진행되는 중간에 새로운 요구사항을 전달하거나 기존의 요구사항을 변경한다. 이는 부정하고 싶어도 부정할 수 없다. 일단 요구사항이 바뀌면 전체 설계는 틀어지게 된다. 어떤 개발자는 재사용을 위한 설계를 하려고 한다. 이는 지나치게 추상적인 프레임워크가 되거나, 또는 재사용이 불가능하게 된다.</p>
<p>또한 설계를 한번에 끝나지 않는다. 설계에 참여한 개발자들은 구현이 어려운 많은 에지 케이스를 생각하고 있기 때문이다. 이러한 어려운 문제들을이 많을 수록 더 많은 일을 해야한다. XP 방법론과 점진적 설계를 활용하면 이러한 어려움을 해결할 수 있다.</p>
<p><strong>반복 계획이 적용될 경우 사용자의 변경 요구사항을 수용할 수 있을 정도로 유연하다.</strong></p>
</div>
</div>
<div class="section" id="id6">
<h2>5.3. 참조<a class="headerlink" href="#id6" title="제목 주소">¶</a></h2>
<ul class="simple">
<li>UseCase: <a class="reference external" href="https://martinfowler.com/bliki/UseCasesAndStories.html">https://martinfowler.com/bliki/UseCasesAndStories.html</a></li>
<li>agile 설계: <a class="reference external" href="http://agilemodeling.com/essays/agileDesign.htm">http://agilemodeling.com/essays/agileDesign.htm</a></li>
<li>agile 분석: <a class="reference external" href="http://agilemodeling.com/essays/iterationModeling.htm">http://agilemodeling.com/essays/iterationModeling.htm</a></li>
<li>구체적인 설계: <a class="reference external" href="http://agilemodeling.com/essays/modelStorming.htm">http://agilemodeling.com/essays/modelStorming.htm</a></li>
<li>tdd: <a class="reference external" href="http://agiledata.org/essays/tdd.html">http://agiledata.org/essays/tdd.html</a></li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Code Accelerator Document</a></h1>








<h3>탐색</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../author.html">관리자 (Author)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../java/java_index.html">자바(Java)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="design_index.html">설계(Design)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="design_terms.html">1. 용어</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_pattern.html">2. 디자인 패턴</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_rest.html">3. Rest API</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_problem.html">4. 소프트웨어 설계 문제</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5. 애자일</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../scala/scala_index.html">스칼라(Scala)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pr_language/language_index.html">프로그래밍 언어(Programming Language)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css/css_index.html">CSS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server/server_index.html">서버(Server)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux/linux_index.html">리눅스</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spring/spring_index.html">Spring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../network/network_index.html">네트워크</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javascript/javascript_index.html">Javascript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netframework/netframework_index.html">.Net Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/python_index.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../database/database_index.html">데이터베이스</a></li>
<li class="toctree-l1"><a class="reference internal" href="../os/operating_system_index.html">운영체제</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datastructure/datastructure_index.html">알고리즘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../statistics/statistics_index.html">통계학(Statictics)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/security_index.html">보안(Security)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ict/ict_index.html">ICT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../etc/etc_index.html">달리 분류되지 않음</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="design_index.html">설계(Design)</a><ul>
      <li>Previous: <a href="design_problem.html" title="이전 장">4. 소프트웨어 설계 문제</a></li>
      <li>Next: <a href="../scala/scala_index.html" title="다음 장">스칼라(Scala)</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="바로 가기" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Choe Changwon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/design/design_agile.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>