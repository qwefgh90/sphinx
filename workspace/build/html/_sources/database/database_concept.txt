.. database_concept:

**********************************
용어
**********************************

============
데이터베이스
============

데이터베이스란 구조적인 데이터를 저장, 조회, 삭제, 수정할 수 있는 소프트웨어다.

데이터베이스의 특징은 다음과 같다.

- 트랜잭션을 이용한 다수의 연결 처리
- 데이터 중복 최소화
- 메타데이터 및 인덱스를 통한 빠른 데이터 조회 및 처리
- 어플리케이션과 데이터를 격리

===================================
데이터베이스 스키마
===================================

**데이터베이스에서 저장하는 데이터의 구조, 형식, 관계를 나타내는 구조이다.** 예를들어 테이블 스키마는 테이블의 속성과 다른 테이블과의 관계를 나타내고 있다. 이때 현재 테이블의 상태를 **외연** , 스키마를 **내포** 라고 한다.

===================================
테이블
===================================

**데이터베이스에서 같은 종류의 데이터를 저장하는 논리적인 공간이다.** 예를들면 메신저 서비스에서는 사용자 데이터를 테이블에 저장할 수 있다.

===================================
카디날리티와 차수
===================================

**차수란 테이블을 구성하는 속성의 수를 뜻하고 카디날리티는 레코드의 수를 뜻한다.**

===================================
RBDMS
===================================

관계를 가지는 데이터를 저장할 수 있는 데이터베이스 시스템이다. 예를들어 네이버 회원은 네이버 메일을 소유할 수 있으므로 1:N의 관계를 맺을 수 있다. 주요 특징으로는 SQL을 통한 질의를 제공하고 행과 열로 구성되어 데이터를 저장할 수 있는 공간인 테이블을 갖고있다. 또한 인덱스, 트랜잭션, 보안 등 부가적인 기능을 일반적인 특징으로 가지고 있다. 

RDBMS는 업무에서 지속적으로 관찰하는 대상을 찾는 데이터 모델링 작업과 정규화(데이터 중복제거)를 통해 최종적으로 테이블을 설계한다. (개체(Entity) 지향 모델)

대규모 서비스(페이스북) 에서는 RDBMS를 Key-Value로 단순하게 사용하기도 한다.

===============
무결성 제약조건
===============

무결성 제약조건이란 데이터베이스가 일관되고 중복없는 데이터를 저장하기위한 규칙을 뜻한다. 도메인 제약조건, 키 제약조건, 기본키 무결성 제약조건, 외래키 무결성 제약조건 등이 있다.

===================================
데이터베이스 락, 로크 (Lock)
===================================

**락이란 하나의 데이터베이스에 여러개의 트랜잭션이 발생했을때 이를 조정하는 역할을 한다.** 각 데이터 항목은 하나의 락과 연관되어 있으며 트랜잭션이 수행을 시작하여 데이터 항목에 접근할 때 마다 락은 **락 테이블** 에 유지된다.

**독점 락(Exclusive lock)** 은 데이터 갱신을 목적으로 접근할때 사용하는 락이다. 이에 반해서 트랜잭션에서 읽을 목적으로 데이터 항목에 접근할 때는 **공유 락(Shared lock)** 을 사용한다.

**현재 걸려있는 락이 독점 락** 이라면 공유 락을 걸 수 없다. **공류 락이나 독점 락** 이 걸려 있는 경우는 독점 락을 걸 수 없다. 오직 **공유 락과 공류 락만 동시에 락을 걸 수 있다.**

=================
트랜잭션 격리조건
=================

1) READ UNCOMMITTED
2) READ COMMITTED
3) REPEATABLE READ
4) SERIALIZABLE

**READ UNCOMMITTED** 는 INSERT UPDATE를 하고 커밋하지 않더라도 다른 트랜잭션 안에서 바뀐 데이터를 읽을 수 있다. SELECT 문에서 공유락을 걸지 않기 때문에 가능하다. 예를들어 트랜잭션후 INSERT와 UPDATE를 하고 있어도 다른 트랜잭션에서 데이터를 읽을 수 있는 것이다.

**READ COMMITTED** 는 COMMIT 할때 까지 **독점 락(변경한 데이터만 행단위 락)** 을 소유하므로 바뀐 데이터를 읽을 수 없다. 하나의 트랜잭션에서 커밋되기 전에 **공유 락** 을 소유하고 즉시 반환하기 때문에 독점 락과 같이 사용이 불가능하다. 다른 특징으로는 하나의 트랜잭션에서 조회를 할때 다른 트랜잭션에서 그 사이에 INSERT나 UPDATE를 할 수 있다.

**REPEATABLE READ** 는 COMMIT 할때 까지 **공유 락(조회한 데이터만 행단위 락)** 을 소유하므로 다른 트랜잭션에서 INSERT나 UPDATE를 할 수 없다. 단 락이 걸려 있지 않은 위치에 레코드를 삽입할 수 있다.

**SERIALIZABLE** 은 COMMIT 할때 까지 **공유 락** 을 조회한 데이터 뿐만아니라 주변 데이터 까지 걸어버린다. 따라서 다른 트랜잭션에서 INSERT나 UPDATE를 전혀 할 수 없다.

=========
팬텀 문제
=========

위의 **REPEATABLE READ** 설명에서 공유락이 걸려있지 않은 레코드는 삽입할 수 있다고 하였다. SELECT 쿼리가 하나의 트랜잭션에 2번이 실행되고 그 사이에 INSERT 쿼리가 발생할 경우 2번째 SELECT 문에서 새로운 데이터가 검색될 것이다.

팬텀 문제 ::
	
	트랜잭션 1

	SELECT ENAME
	FROM EMPLOYEE
	WHERE DNO = 1;

	트랜잭션 2

	INSERT INTO EMPLOYEE
	VALUES(3474, '정희연', '사원', 2106, 1500000, 1);

	트랜잭션 1 (아직 트랜잭션 내부)

	SELECT ENAME
	FROM EMPLOYEE
	WHERE DNO = 1;


===================================
물리적 데이터 베이스
===================================

데이터베이스의 데이터는 파일, 블록(페이지), 레코드 이라는 구조로 저장된다. **파일은 블록의 집합이며 블록은 레코드의 집합이다.** 파일은 하나의 테이블을 저장할 수도 있고 여러개의 테이블을 저장할 수도 있다. `블록단위 I/O <http://wiki.gurubee.net/pages/viewpage.action?pageId=26739100>`_

데이터베이스 에서는 **블록단위 I/O** 를 수행한다. **그 이유는 Sequential Access가 I/O효율이 좋기 때문이다. 즉 블록 I/O를 하는 이유는 Random Access가 아닌 Sequential Access를 최대한 많이 하려는 노력이다.** 

한번의 블록 I/O로 최대한 많은 데이터를 읽어서 성능을 향상 시키는 것이다. `Native Command Queue와 <http://ko.wikipedia.org/wiki/NCQ>`_  `비순사적 명령어 처리(CPU) <http://ko.wikipedia.org/wiki/%EB%B9%84%EC%88%9C%EC%B0%A8%EC%A0%81_%EB%AA%85%EB%A0%B9%EC%96%B4_%EC%B2%98%EB%A6%AC>`_ 와 비슷한 원리이다. 

**데이터 접근 성능 향상을 위해 I/O요청 큐에 있는 데이터 각각을 위해 하나의 블록을 여러번 접근하는 것이** 아닌 이를 데잍러르 정렬하여 한번의 블록 I/O로 대부분의 데이터를 읽어오는 방식이다. 즉 Sequential Access를 높이기 위해 이런 방식을 고집하고 있는 것이다. 반대로 하나를 위해 하나의 블록만 접근하는 것을 Random Access라 한다.

파일의 종류에는 **히프 파일(비 순차), 순차 파일** 이 있다. 비 순차 파일은 삽입 시간이 짧고 순차파일은 탐색시간이 짧다고 한다.

===================================
NoSQL
===================================

`참고 할만한 글 <http://hochul.net/blog/nosql_mongodb_rdbms_alternative/>`_

**Not Only SQL이라는 뜻을 지닌 제품으로 삽입 삭제와 같은 단순한 연산을 제공하면서 분산 확장을 지원하는 데이터베이스를 뜻한다.** 대규모 서비스가 등장하면서 데이터가 쌓이는 속도가 빨라지며 동시에 많은 요청을 처리해야하는 경우가 많아졌다. 기존의 RDMS는 분산을 고려하여 나온 제품이 아니기 때문에 확장성 면에서 NoSQL에 비해 부족하고 삽입/삭제와 같은 단순한 명령에서 NoSQL이 빠른 성능을 보이고 있다.

**NoSQL이 RDBMS에 비해 가지는 장점은 다음과 같다.**

- 분산 저장이 더 쉽고 가용성이 높다.

RDBMS를 복제(Query off loading)를 통해 확장할 경우 Write연산에 병목이 발생한다. 이를 Master를 2개의 DB로 분산하면 충돌 (무결성 위반이나 인덱스 불일치와 같은 문제) 문제가 발생하므로 분산이 쉽지 않다. 또한 수직 샤딩을 할 경우 관계 테이블을 모아놓지 않으면 특별한 솔루션의 힘을 받지 않는한 JOIN 연산은 어렵다. 이러한 JOIN을 어플리케이션에서 구현해야한다. 반면 NoSQL은 샤딩과 복제를 기본적으로 지원하는 경우가 많다. (MongoDB Auto sharding 지원)

- 분산 RDMS는 비싸다.
- 단순한 삽입/삭제 연산만 지원하기 때문에 빠른 읽기/쓰기 속도를 가지고 있다.
- RDBMS의 쿼리는 트랜잭션 보장을 위해 NoSQL의 단순한 연산에 비해 오래걸린다.
- 고정된 스키마는 인덱스 변환시 문제를 발생시킨다.

새로운 요구사항이 발생했을때 테이블의 칼럼 추가/수정/삭제와 인덱스의 수정은 테이블에 락을 걸기 때문에 문제가 발생한다고 한다. `MySQL에서는 ALTER TABLE시 테이블 WRITE 락이 발생 <http://dev.mysql.com/doc/refman/5.5/en/alter-table.html>`_ , `MySQL에서는 CREATE INDEX를 할때 WRITE 락이 발생 <https://dev.mysql.com/doc/refman/5.0/en/create-index.html>`_ `해결책1 <https://signalvnoise.com/posts/3174-taking-the-pain-out-of-mysql-schema-changes>`_ , `해결책2 <http://devday.tistory.com/2191>`_

**ALTER TABLE 절차 (테이블 락)**

1) 임시 테이블로 데이터 복사
2) 원래 테이블 삭제
3) 새로운 테이블 이름을 변경
4) 다른 세선에서 읽을 수 있으나 UPDATE, INSERT문은 새로운 테이블이 생성이 될 때까지 수행되지 않는다.

**NoSQL의 단점은 다음과 같다.**

- NoSQL이 익숙하지 않은데서 오는 개발자들의 어려움이 있다.
- 관계(Relation)이 없기 때문에 복잡한 구조를 처리하기 어렵다.
- 데이터 중복이 많아져서 저장 효율은 떨어진다.
- 인덱싱과 트랜잭션(ACID) 지원이 없는 솔루션이 많다.
- Join 연산이 어렵다

NoSQL은 BASE의 특성을 따른다. Basically Available(기본적인 가용성), Soft-state(시간이 지나면 데이터가 expire될 수 있다), Eventually consistency(결과적으로 일관성을 띈다)이다.

NoSQL은 테이블 디자인이 아닌 쿼리디자인을 먼저한다. 업무에서 필요한 정보에 대한 쿼리를 만들고 쿼리를 바탕으로 저장한 데이터 테이블을 설계한다. 이때 쿼리를 위해 데이터를 중복을 허용해서 테이블을 정의해야한다. 일반적으로 RDBMS처럼 정규화를 하면 성능문제가 발생하게 된다고 한다. (쿼리 지향)



