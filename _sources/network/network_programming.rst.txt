.. _network_programming:

************************************************
네트워크 프로그래밍
************************************************

============================
블로킹 기법 vs 논블로킹 기법
============================

:ref:`블로킹 기법 <network_terms_블로킹_기법>` 을 활용한 I/O의 단점은 사용자의 수만큼 스레드를 생성하기 때문에 많은수의 사용자를 처리하기 위해 여러번의 스레드 컨텍스트 스위칭이 발생하여 성능이 줄어든다. Tomcat이 이런 구조라고 한다. 반면 :ref:`논블로킹 기법 <network_terms_논블로킹_기법>` 은 스레드를 일정량 생산한 후 여러개의 I/O 채널을 관리하게 하고 이벤트-리스너 구조를 이용한다. 이때 대기하던 워커 쓰레드가 작업(Task)을 처리할 수 있다. 단점으로 스위칭 비용이 줄어드나 코드의 제어가 복잡해진다. `네티 NIO 아키텍처 <http://ayedo.github.io/netty/2013/06/19/what-is-netty.html>`_ `IOCP 란 <http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/win_network_prog/doc/iocp>`_

즉 큰 차이점으로 스레드 컨텍스트 스위칭 비용이 있다. 동시에 500개의 연결이 들어온다면 스레드 500개가 각각을 처리하게되어 컨텍스트 스위칭 비용이 들지만 비동기 방식이라면 이런 비용없이 처리할 수 있다. **하지만 각 이벤트 또는 작업에 대한 비용이 많이 든다면 성능이 떨어진다고 한다.**

이때 블로킹 기법은 동기적 방법에 해당한다. OS의 작업완료가 될때까지 프로세스는 대기한다. 반면 논블로킹 기법은 무한정 busy-waiting을 할 수도있지만 이것이 아닌 OS단에서 비동기적 방식의 지원으로 인해 시그널로 알림을 받는다. **자바에서는 Select라는 클래스를 이용해 알림을 받을 수 있다고 한다.**

==========================================
게임 동기화 모델
==========================================

`게임 네트워크 아키텍처 <http://www.gamedevforever.com/m/post/62>`_
`게임 네트워크 아키텍처 메뉴얼 추천 <http://www.gabrielgambetta.com/fpm1.html>`_
`Authoritative Server 설명 <http://blog.naver.com/zzleggam/70176251463>`_

- 클라이언트 시간에 맞추는 방식 : 게임 진행중에 P2P형태로 연결되며 **가장 지연이 오래걸리는 클라이언트의 시간에 맞춘다.** 해킹에 약한 모델이다.

- 서버시간에 맞추는 방식 (서버의 응답 대기) : 서버가 클라이언트 행동에 대해 모든 판단을 내리게 된다. **클라이언트는 서버의 응답을 기다린뒤 행동한다.** 응답이 빠른 유저는 더욱 민첩하게 움직일 수 있다. 장점으로는 해킹에 강한 모델이다. 단점으로는 서버에서 응답이 늦어진다면 사용자가 답답해 할 수 있다.

- 서버시간에 맞추는 방식 (서버의 응답을 대기하지 않음) : 서버가 클라이언트 행동에 대해 판단(결정)을 내리지만 **유저는 서버의 응답을 기다리지 않고 이동한다.** 장점은 해킹에 강한 모델이라는 것이고 사용자의 화면을 응답 지연없이 빠르게 전환 시킬 수 있다. 단점은 서버에서 응답이 늦어질 경우 다른 플레이어에 의해 갑작스럽게 화면이 변할 수 있다.

- 멀티 플레이 게임 : 낮은 주기로 서버의 상태와 클라이언트 상태를 동기시킨다. 예를들어 100ms 마다 서버의 새로운 상태를 받을 수 있다.

- 데드 레커닝 (추측 항법) : 서버시간에 맞추는 방식이지만 자동차 게임과 같이 계속 움직이는 게임은 다른 플레이어의 상태를 추측해서 움직여야 할 것이다.

여기서 클라이언트의 요청을 결정하는 응답하는 서버를 **권한 집중 서버(Authoritative Server)** 라고 한다.

