<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4. 알고리즘 문제 모음 &#8212; Code Accelerator Document 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="next" title="5. 잘 알려진 알고리즘 분석" href="well_known_algorithm.html" />
    <link rel="prev" title="2. 자료구조" href="data_structure.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>4. 알고리즘 문제 모음<a class="headerlink" href="#id1" title="제목 주소">¶</a></h1>
<p><a class="reference external" href="https://github.com/qwefgh90/AlgorithmSolution">알고리즘 풀이 소스코드 저장소</a></p>
<div class="section" id="id3">
<h2>4.1. 개미수열<a class="headerlink" href="#id3" title="제목 주소">¶</a></h2>
<img alt="../_images/q1.png" src="../_images/q1.png" />
<p>개미 수열, 읽고 말하기 수열이라고 불린다. 해답은 이전항을 읽고 말하면 다음항이 된다. 1시간 동안 고민했으나 너무어려워서 4개 이상의 억지 규칙을 찾을 수 있었다... 하지만 답은 아닌듯. (A개의 B라고 읽으면 해결할 수 있다.)</p>
<p>읽고 말하기 수열은 다음과 같이 시작하는 수열이다. 대한민국에서는 소설 개미에서 소개되면서 유명해졌기 때문에, 개미 수열이란 이름으로 잘 알려져 있다. <a class="reference external" href="http://ko.wikipedia.org/wiki/%EC%9D%BD%EA%B3%A0_%EB%A7%90%ED%95%98%EA%B8%B0_%EC%88%98%EC%97%B4">개미수열</a></p>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-comments" data-href="http://qwefgh90.github.io/datastructure/algorithm_question.html#id2" data-numposts="5" data-colorscheme="light"></div></div>
<div class="section" id="coins">
<h2>4.2. COINS<a class="headerlink" href="#coins" title="제목 주소">¶</a></h2>
<p>알고스팟의 COINS라는 문제이다. <a class="reference external" href="https://www.algospot.com/judge/problem/read/COINS">COINS</a> 예를들어 우리나라 화폐가 5원, 15원, 20원 이있다면 40원이란 돈을 표현하는 가지의 수를 구하라와 같은 문제이다.</p>
<p>가장 처음 접했을때는 당연하게도.. 40원을 가장 큰 단위의 돈으로 표현하고 예를들면 40=20+20, 20=5*4 , 20=15+5, 15=5*3와 같이 변형과정을 쭉 나타내 보았다. 하지만 경우의 수를 구하는 방법을 정확하게 나타낼 수 없었다. 중복도 발생하고 동전이 서로 배수관계도 아니기 떄문에 모든 경우의 수를 찾기 어려웠다. 결론은 스스로 풀지 못했다. 알고리즘 잘하는 형에게 도움을 청해 방법을 들었는데... 결론은 DP로 풀 수 있는 문제였다.</p>
<p>모든 경우의 수를 표로 나타내면서 재귀식과 해를 구할 수 있는 동적 계획법을 사용하면 쉽게 풀 수 있는데 아래 표를 보자.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="9%" />
<col width="6%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">잔돈 종류  / 금액</th>
<th class="head">0</th>
<th class="head">5</th>
<th class="head">10</th>
<th class="head">15</th>
<th class="head">20</th>
<th class="head">25</th>
<th class="head">30</th>
<th class="head">35</th>
<th class="head">40</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>5</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="row-even"><td>20</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>첫번째 행은 잔돈의 종류가 5원만 있을때의 경우의 수를 나타내었다. 5원일 때는 모든 금액을 1가지로 밖에 표현할 수 없다. 0원에 채워 넣은 이유는 실제로 점화식에서 편하게 계산하기 위해서 이다. 잔돈이 15원 (0원, 15원) 일 때 부터 중요하다. 금액이 10이하 일 때는 15원을 사용할 수 없다.</p>
<p>금액이 15원일 경우 5원으로 표현할 수 있는 가지수 + 금액 0원을 표현하는 가지수(15원은 15 + 0이라 그렇다.)이다.(2개 -&gt; 5-3개, 15-1개) 금액이 30원일 경우 5원으로 표현할 수 있는 가지수 + 금액 15원을 표현하는 가지수(30원은 15 + 15이라서 그렇다.)이다. (3개 -&gt; 5-6개, 5-3개 15-1개, 15-1개 15-1개)</p>
<p>핵심은 (15-1개 + 5-3개, 5-3개 + 15-1개)와 같이 다른 표현인것 같지만 교환법칙이 성립하기 떄문에 같은 경우로 보는 성질이 있다는 것이다. 점화식은 f(현재 잔돈, 금액) = f(현재 잔돈, 금액 - 잔돈의 크기) + f(이전 잔돈, 금액) 와 같다.</p>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-comments" data-href="http://qwefgh90.github.io/datastructure/algorithm_question.html#COINS" data-numposts="5" data-colorscheme="light"></div></div>
<div class="section" id="shortest-palindrome">
<h2>4.3. Shortest Palindrome을 만들어라<a class="headerlink" href="#shortest-palindrome" title="제목 주소">¶</a></h2>
</div>
<div class="section" id="bst">
<span id="index-0"></span><h2>4.4. 이진 탐색(BST) 응용<a class="headerlink" href="#bst" title="제목 주소">¶</a></h2>
<p>정렬된 배열에서 O(logN)의 시간안에 값을 찾는 방법에는 이진 탐색이 있다. (O는 최악의 경우를 나타내는 시간 복잡도 표기법)</p>
<p>최근에 <a class="reference external" href="https://code.google.com/codejam/contest/dashboard?c=2974486#s=a&amp;a=3">GCJ의 Deceitful War</a> 을 풀면서 이진 탐색을 응용해본 경험이 있다. 즉 이진 탐색처럼 아예 같은 값을 찾거나 없을경우 큰 값중 가장 작은 값을 찾는 알고리즘이다.</p>
<p>기본적으로 이진 탐색을 구현한 후 같은 값이 없는 케이스에서 예외처리를 해주면 구할 수 있다.</p>
<ol class="arabic simple">
<li>알고리즘 내에서 start가 end보다 크게되는 경우는 start를 반환하면됨</li>
<li>알고리즘 내에서 start와 end가 같은 경우는 start index안의 값이 작으면 start+1반환 크면 start반환</li>
</ol>
<p>반대로 같거나 작은 값은 1) 2)에서 조건을 조금만 수정하면 될듯하다.</p>
<p>실제 코드는 다음과 같다.:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">//이분 탐색</span>
<span class="c1">//같거나 큰값</span>
<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">double</span> <span class="n">target</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">minPeek</span><span class="p">())</span> <span class="c1">//인덱스 0 반환</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">maxPeek</span><span class="p">())</span> <span class="c1">//존재하지 않음</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">sindex</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//+1을 안해주어도 된다.</span>

  <span class="c1">//큰값 중 가장 작은값</span>
  <span class="c1">//예 1 2 4 중에서 start와 end 둘다 2인 경우 또는 4인 경우 나눠서 처리해야함</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">]){</span>
      <span class="k">return</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//큰값 중 가장 작은값</span>
  <span class="c1">//예) 1 2 4  에서 end가 2 start가 4를 가르치는 경우 start를 반환해야 한다.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//같은값</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="n">sindex</span><span class="p">]){</span>
    <span class="k">return</span> <span class="n">sindex</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">sindex</span><span class="p">]){</span>

    <span class="c1">//같으면 큰값중 가장 작은값</span>
    <span class="cm">/*if (sindex + 1 == end)</span>
<span class="cm">      return start;*/</span>
    <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">sindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">sindex</span><span class="p">]){</span>

    <span class="c1">//같으면 큰값중 가장 작은값</span>
    <span class="cm">/*if (start == sindex - 1)</span>
<span class="cm">      return start+1;*/</span>
    <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">sindex</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-comments" data-href="http://qwefgh90.github.io/datastructure/algorithm_question.html#bst" data-numposts="5" data-colorscheme="light"></div></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. 알고리즘 문제 모음</a><ul>
<li><a class="reference internal" href="#id3">4.1. 개미수열</a></li>
<li><a class="reference internal" href="#coins">4.2. COINS</a></li>
<li><a class="reference internal" href="#shortest-palindrome">4.3. Shortest Palindrome을 만들어라</a></li>
<li><a class="reference internal" href="#bst">4.4. 이진 탐색(BST) 응용</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="datastructure_index.html">알고리즘</a><ul>
      <li>Previous: <a href="data_structure.html" title="이전 장">2. 자료구조</a></li>
      <li>Next: <a href="well_known_algorithm.html" title="다음 장">5. 잘 알려진 알고리즘 분석</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>현재 문서</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/datastructure/algorithm_question.rst.txt"
            rel="nofollow">소스 코드를 보려면</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="바로 가기" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Choe Changwon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/datastructure/algorithm_question.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>