

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. 자바 기본 &mdash; Changchang Documentation 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Changchang Documentation 1.0 documentation" href="../index.html" />
    <link rel="up" title="자바(JAVA)" href="java_index.html" />
    <link rel="next" title="2. JVM" href="java_jvm.html" />
    <link rel="prev" title="자바(JAVA)" href="java_index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="java_jvm.html" title="2. JVM"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="java_index.html" title="자바(JAVA)"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Changchang Documentation 1.0 documentation</a> &raquo;</li>
          <li><a href="java_index.html" accesskey="U">자바(JAVA)</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>1. 자바 기본<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>1.1. 자바 동기화 (임계영역 해결책)<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p><strong>자바의 모든 객체는 각각 하나의 락, entry queue(entry set), waiting queue(waiting set)를 가지고 있다. 즉 자바의 객체는 Monitor처럼 행동한다.</strong> 즉 객체는 락으로 사용된다.</p>
<p><a class="reference external" href="http://www.xyzws.com/javafaq/why-wait-notify-notifyall-must-be-called-inside-a-synchronized-method-block/127">entry queue, waiting queue 정보</a> 를 확인해 보자.</p>
<ul class="simple">
<li>synchronized 키워드를 이용하는 방법 (메서드, 블록)</li>
<li>wait(), notifyAll() 을 이용하는 방법</li>
</ul>
<p>synchronized 동기화 과정</p>
<ol class="arabic simple">
<li>스레드가 동기화 메서드를 호출했을 때 이미 다른 스레드가 락을 획득하고 있다면 스스로를 락을 대기하는 집입집합(entry queue)에 넣고 스스로 봉쇄한다.</li>
<li>락이 사용가능 하다면 진입 집합(entry queue)에 있는 한 스레드가 새로운 소유주가 되고 임계영역을 실행한다.</li>
</ol>
<p>wait()와 notify()방식의 특징</p>
<ul class="simple">
<li>두개의 메서드는 synchronized 블록 내에서만 사용할 수 있다. 또한 블록의 락과 동일한 객체로 호출해야 한다. 만약 락을 소유하고 있지 않다면 <strong>java.lang.IllegalMonitorStateException</strong> 를 발생시킨다. 이는 현재 스레드가 락의 소유주가 아니라는 뜻이다.</li>
<li>wait()를 호출하면 waiting queue에 자신을 넣고 락을 반환한다.</li>
<li>synchronized에 진입한 다른 스레드가 동일한 객체의 notifyAll()을 호출해서 waiting queue의 스레드를 entry queue로 이동한다.</li>
<li>notifyAll()을 호출하고 이후 소유하는 락을 반환하면 entry queue중 notifyAll()로 깨어난 스레드가 우선적으로 수행된다. (이는 반복 실행을 통해 발견한 규칙이다. 어쩌면 당연한것이라고 볼 수 있음)</li>
</ul>
<p><strong>블록을 잡은 부분을 보면 waiting 큐에서 깨어난 쓰레드가 먼저 실행되는 모습을 볼 수있다.</strong> 그밑에는 entry queue에 있던 다른 스레드들이 출력하는 메세지이다. 즉 waiting 큐에서 꺠어난 쓰레드가 우선적으로 실행되는 것을 알 수 있다.</p>
<img alt="../_images/waitnotify.png" src="../_images/waitnotify.png" />
<div class="section" id="notifyall-vs-notify">
<h3>1.1.1. notifyAll() vs notify()<a class="headerlink" href="#notifyall-vs-notify" title="Permalink to this headline">¶</a></h3>
<p><strong>notify()는 하나의 스레드만 깨우기 때문에 특정 스레드가 오랫동안 실행되지 않을 경우가 생길 수 있다. 따라서 notifyAll()을 이용해 모든 스레드를 깨운뒤 JVM의 스레드 스케줄링에 의해 처리되도록 한다.</strong></p>
</div>
</div>
<div class="section" id="generic">
<h2>1.2. 자바 Generic<a class="headerlink" href="#generic" title="Permalink to this headline">¶</a></h2>
<div class="section" id="type-erasure">
<h3>1.2.1. 타입 제거 (Type Erasure)<a class="headerlink" href="#type-erasure" title="Permalink to this headline">¶</a></h3>
<p>제너릭에 사용되는 기술이다. 타입제거 기술의 역할을 다음과 같다.</p>
<ul class="simple">
<li>모든 제너릭 타입을 Object나 제너릭의 부모 타입이 있다면 그것으로 바꾼다.</li>
<li>원래의 타입이 필요한 부분에 타입 캐스트 구문을 넣는다.</li>
<li>부모와 자손의 제너릭 타입이 다를 경우 내부적으로 타입 불일치가 발생할 수 있기 때문에 컴파일 시간에 브리지 메서드를 추가한다. <a class="reference external" href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html">브리지 메서드</a></li>
</ul>
<p>아래와 같은 경우에 T는 Object로 replace 되기 때문에 부모 참조자로 자식 객체를 업캐스팅한 상태에서 인자로 아무 객체나 넣을 수 있다.</p>
<p>Type Erasure 이전</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="n">data</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Node.setData&quot;</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyNode</span> <span class="kd">extends</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">MyNode</span><span class="o">(</span><span class="n">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="kd">super</span><span class="o">(</span><span class="n">data</span><span class="o">);</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;MyNode.setData&quot;</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">MyNode</span> <span class="n">mn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mn</span><span class="o">;</span>            <span class="c1">// A raw type - compiler throws an unchecked warning</span>
        <span class="n">n</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="s">&quot;any type&quot;</span><span class="o">);</span>
</pre></div>
</div>
<p>제네릭을 분석해보고 MyNode에 브리지 메서드(오버라이드 메서드)를 만들어서 타입 불일치 현상을 해결한다.</p>
<p>Type Erasure 이후:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">MyNode</span> <span class="kd">extends</span> <span class="n">Node</span> <span class="o">{</span>

    <span class="c1">// Bridge method generated by the compiler</span>
    <span class="c1">//</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">Object</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setData</span><span class="o">((</span><span class="n">Integer</span><span class="o">)</span> <span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;MyNode.setData&quot;</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="c">
<h3>1.2.2. 자바 제너릭과 C++ 템플릿과의 차이점<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>제너릭과 템플릿은 설계시 클래스 내부적으로 사용되는 타입을 결정하는 것이 아닌 클래스를 사용할 때 타입을 결정할 수 있게 하는 기술이다.</p>
<ul class="simple">
<li>C++에서는 다른 타입을 템플릿 인자로 받으면 각각 클래스의 static변수가 생기지만 Java에서 생성된 클래스들은 static 변수를 공유한다.</li>
<li>C++ 템플릿에서는 int와 같은 기본 타입을 인자로 넘길 수 있지만, Java의 경우 기본타입을 넘길 수 없다. 대신 Integer와 같은 Wrapper클래스를 넘긴다.</li>
<li>Java Generic은 특정 클래스의 하위클래스만 인자로 받을 수 있도록 제한할 수 있다. 예를들어 class Line&lt;T extends Integer&gt;{} 와 같이 Integer의 하위클래스만 사용할 수 있도록 제한할 수 있다.</li>
<li>C++은 템플릿 인자로 객체를 만들 수 있지만 Java는 제너릭 인자로 객체(new 키워드가 안될 뿐 변수로 쓸 수있다.) 를 만들 수 없다.</li>
<li>C++은 템플릿 인자로 static 변수와 메서드를 선언할 때 사용할 수 있지만 Java는 static변수나 메서드에 사용할 수 없다. 이는 템플릿은 새로운 클래스형을 만들지만 Java 제너릭은 새로운 형을 만들지 않으며 타입제거 기법을 사용하기 때문이다.</li>
<li>C++ 템플릿에서 다른 타입의 인자로 만들어진 템플릿 객체는 서로 다른 타입이지만 ( stack&lt;int&gt; 와 stack&lt;float&gt; 은 다른타입) Java 제너릭에서 다른 타입의 인자로 만들어진 ( ArrayList&lt;String&gt; 와 Array&lt;Integer&gt;  은 같은 타입)</li>
</ul>
<p>서로 다른 타입임을 알 수 있다.</p>
<img alt="../_images/c++.png" src="../_images/c++.png" />
<p>Java에서는 객체생성, static멤버나 변수에 사용이 불가능한 것을 볼 수 있다.</p>
<img alt="../_images/제너릭.png" src="../_images/제너릭.png" />
</div>
</div>
<div class="section" id="id4">
<h2>1.3. 자바의 예외<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p><strong>리턴값으로 false, true, 에러코드 를 주면되지 라고 생각할 수 있지만 에러코드 체계가 명확하게 잡혀있지 않다면 직관적이지 못한 방법이다. 따라서 Java의 예외는 에러코드보다 명시적이고 역시 컴파일 시간에 개발자에게 처리를 강제하기 때문에 기능적인 면에서도 뛰어나다.</strong></p>
<p><strong>프로그램 에러에는 컴파일 에러, 런타임 에러가 있다. 자바에서는 런타임 에러를 &#8216;에러(error)&#8217;와 &#8216;예외(exception)&#8217; 두가지로 나눴다. 자바의 에러는 프로그램에서 처리될 수 없는 에러를 뜻한다. 프로그래머가 어려운 경우가 많다. 하지만 자바의 예외는 프로그램에서 적절히 처리될 수 있다.</strong></p>
<ol class="arabic simple">
<li>자바의 에러는 JVM에서 발생시키는 경우가 많다.</li>
</ol>
<p>java.lang.Error를 상속받는 종류로 OutofMemoryError나 ThreadDeath와 같은 에러가 있다.</p>
<ol class="arabic simple" start="2">
<li>Exception 언체크 예외</li>
</ol>
<p>java.lang.RuntimeException을 상속받는 종류의 예외는 소스코드 레벨에서 체크되지 않는다. 대표적으로 런타임 예외라는 말을 쓴다. 하지만 체크 예외도 실행중에 발생하는 예외이다. 이는 Error와 마찬가지로 처리될 수 없는 예외이다.</p>
<ol class="arabic simple" start="3">
<li>Exception 체크 예외</li>
</ol>
<p>체크예외가 발생한다면 반드시 try-catch 구문으로 처리하거나 throws을 이용해 예외를 전가해야한다.</p>
<div class="section" id="runtime-exception">
<h3>1.3.1. 언체크 예외의 목적(Runtime Exception)<a class="headerlink" href="#runtime-exception" title="Permalink to this headline">¶</a></h3>
<p><strong>프로그래머들의 실수로 발생하여서 바로 복구가 불가능한 예외이다.</strong> 설마 여기서 실수를 하겠어? 라고 생각하지만 진짜 실수를 할 경우 발생시키는 예외라 볼 수 있다.</p>
<p>이는 프로그래머에게 근본적으로 문제를 바꾸기를 요구하는 예외이다. 예를들면 <strong>NullPointerException</strong> , <strong>IndexOutOfBoundsException</strong> , <strong>ClassCastException</strong> 과 같은 예외는 개발의 실수로 인해 발생하는 예외이다.</p>
<p><strong>물론 예외를 처리할 수 있지만 근본적으로 코드상에서 바꿔야할 문제이다. 따라서 컴파일 시간에 try-catch를 이용한 처리를 요구하지 않는다.</strong></p>
</div>
<div class="section" id="id5">
<h3>1.3.2. 체크 예외의 목적(Runtime Exception을 제외한 예외)<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p><strong>사용자의 실수와 같은 외적인 요인에 의해 발생하며 처리할 수 있는 예외이다. 따라서 프로그래머가 개발할 당시 try-catch로 명시적으로 처리하길 요구한다.</strong></p>
<p>이 예외는 외부요인에 의해 문제가 발생할 수 있으니 처리하길 요구하는 역할을 한다. 클라이언트나 외부요인의 예로는 <strong>FileNotFoundExcetpion</strong> , <strong>ClassNotFoundException</strong> , <strong>DataFormatException</strong> 이 있다.</p>
<p><strong>컴파일 시간에 try-catch를 이용해 명시적 예외처리를 하기를 요구한다.</strong></p>
</div>
</div>
<div class="section" id="collection">
<h2>1.4. 컬렉션 프레임워크(Collection)<a class="headerlink" href="#collection" title="Permalink to this headline">¶</a></h2>
<p>자바 컬렉션 프레임워크는 여러개의 데이터를 저장하고 관리할 수 있는 표준 프레임워크이다.</p>
<p>유용한 함수:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">srcObj</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">destObj</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">//원본 배열 0번지에서 목적지 0번으로 10개의 객체를 복사한다.</span>
</pre></div>
</div>
<div class="section" id="list-set">
<h3>1.4.1. List &amp; Set<a class="headerlink" href="#list-set" title="Permalink to this headline">¶</a></h3>
<p>List와 Set은 java.util.Collection 인터페이스를 상속받은 Java의 인터페이스이다. List는 순서를 갖고 중복을 허용하는 집합이다. Set은 데이터의 중복을 허용하지 않는 집합이다.</p>
<p><strong>List와 Set의 차이점은 데이터의 순서보장과 데이터 중복여부이다.(Set이 기본적으로 순서를 보장하지 않지만 Tree기반일 경우 삽입의 순서보장 대신 정렬기능을 지원한다.)</strong></p>
<p><strong>List</strong> 를 상속한 클래스는 Vector, ArrayList, LinkedList, Stack등이 있다. <strong>Set</strong> 을 구현한 클래스는 HashSet, SortedSet, TreeSet이 있다.</p>
<p>List에 값 추가/삭제:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">T</span> <span class="n">object</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>
<span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">T</span> <span class="n">object</span><span class="o">);</span>  <span class="c1">//지정된 위치에 값 삽입</span>
<span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>

<span class="n">Object</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">T</span> <span class="n">object</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="nf">removeAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="nf">retainAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>

<span class="n">Object</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">Object</span> <span class="n">element</span><span class="o">);</span> <span class="c1">//지정된 위치에 원소 수정</span>
</pre></div>
</div>
<p>List의 용량조절</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">ensureCapacity</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">);</span> <span class="c1">//최소 수용량 결정</span>
<span class="kt">void</span> <span class="nf">trimToSize</span><span class="o">();</span> <span class="c1">//빈 공간을 없앤다. 결과적으로 capacity 값을 최소로 조절하게된다.</span>
</pre></div>
</div>
<p>List의 특정원소의 인덱스 검색:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span>
<span class="kt">int</span> <span class="nf">lastIndexOf</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span>
</pre></div>
</div>
<p>새로운 배열이 생성되고 복사되는 과정에서 부하를 일으킨다.</p>
</div>
<div class="section" id="arraylist">
<h3>1.4.2. ArrayList의 장/단점<a class="headerlink" href="#arraylist" title="Permalink to this headline">¶</a></h3>
<p>장점</p>
<ol class="arabic simple">
<li>순차적인 추가와 삭제에 빠른 성능을 보인다. (추가와 삭제가 배열의 뒷부분에 일어날 경우)</li>
<li>랜덤검색이 빠르다.</li>
</ol>
<p>단점</p>
<ol class="arabic simple">
<li>배열의 크기를 동적으로 조절하기위해 새로운 배열에 복사하는 방식을 택하기 때문에 비용이 많이 발생한다.</li>
<li>이러한 상황을 줄이기 위해 가지고 있는 데이터보다 큰 공간을 잡기때문에 메모리 낭비가 발생한다.</li>
<li>배열의 중간에 요소를 삽입하거나 제거할때 배열 전체를 이동해야하기 때문에 많은 비용이 발생한다.</li>
</ol>
</div>
<div class="section" id="linkedlist">
<h3>1.4.3. LinkedList의 장/단점<a class="headerlink" href="#linkedlist" title="Permalink to this headline">¶</a></h3>
<p>장점</p>
<ol class="arabic simple">
<li>리스트의 중간에 값을 추가/삭제할때 ArrayList에 비해 비용이 적다.</li>
<li>필요한 만큼만 공간을 차지하기 때문에 ArrayList에 비해 메모리를 적게 사용한다.</li>
</ol>
<p>단점</p>
<ol class="arabic simple">
<li>랜덤검색을 할 경우 선형검색을 통해 검색하기 때문에 속도가 느리다.</li>
</ol>
</div>
<div class="section" id="stack-queue">
<h3>1.4.4. Stack과 Queue<a class="headerlink" href="#stack-queue" title="Permalink to this headline">¶</a></h3>
<p>JCF에서는 Stack과 Queue를 제공한다.</p>
<p>먼저 Stack은 Vector를 상속하여 구현되었다. 다음과 같은 연산을 지원한다.:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">T</span> <span class="nf">push</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span>
<span class="n">T</span> <span class="nf">pop</span><span class="o">();</span>
<span class="n">T</span> <span class="nf">peek</span><span class="o">();</span>
<span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span> <span class="c1">//주어진 객체를 찾아서 그 위치를 반환한다. (배열과 달리 인덱스는 1부터 시작한다.)</span>
</pre></div>
</div>
<p>Queue는 Stack과 달리 그 자체는 인터페이스이다.:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span>   <span class="c1">//큐에 삽입</span>
<span class="n">Object</span> <span class="nf">peak</span><span class="o">();</span>  <span class="c1">//삭제하지 않고 값을 반환</span>
<span class="n">Object</span> <span class="nf">poll</span><span class="o">();</span>  <span class="c1">//큐에서 꺼내온다.</span>
</pre></div>
</div>
<p><strong>Stack의 예는 다음과 같다.</strong></p>
<ul class="simple">
<li>브라우저 페이지 네비게이터</li>
</ul>
<p><strong>Queue의 예는 다음과 같다.</strong></p>
<ul class="simple">
<li>잡 스케줄러에서 사용되는 대기큐(Waiting Queue) (우선순위 큐)</li>
<li>최근 명령어 히스토리 (리눅스 history)</li>
</ul>
<p><strong>Queue 인터페이스를 구현한 클래스 목록</strong></p>
<ul class="simple">
<li>LinkedList, ConcurrentLinkedQueue, PriorityQueue</li>
</ul>
</div>
<div class="section" id="id6">
<h3>1.4.5. 동기화 보장<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Vector와 HashTable을 thread-safe 하지만 개발된지 오래된 클래스이므로 현재는 아래와 같은 방식으로 동기화를 처리한다.</p>
<p>Collections 클래스를 활용:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">static</span> <span class="n">List</span> <span class="nf">synchronizedList</span><span class="o">(</span><span class="n">List</span> <span class="n">list</span><span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>1.4.6. 얕은복사와 깊은복사<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>얕은복사는 자바의 참조값을 전달하는 복사를 뜻한다. 깊은 복사는 포함하는 내용이 같은 복사본을 생성하는 것을 뜻한다.</p>
</div>
<div class="section" id="id8">
<h3>1.4.7. 정렬<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Collections.sort(Collection c, Comparator comparator);</p>
</div>
<div class="section" id="hashset">
<h3>1.4.8. HashSet<a class="headerlink" href="#hashset" title="Permalink to this headline">¶</a></h3>
<p>HashSet은 해시값을 이용해 원소들의 중복을 허용하지 않고 순서를 유지하지 않는 집합이다. HashSet은 중복검사를 위해 hashCode()의 결과값과 (eqauls() || 참조값 비교)의 결과값을 사용한다.</p>
<p><strong>순서를 유지하기 위해선 LinkedHashSet을 사용해야한다.</strong></p>
<p>합집합, 교집합, 차집합:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>           <span class="c1">//합집합</span>
<span class="kt">boolean</span> <span class="nf">retainAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>        <span class="c1">//교집합</span>
<span class="kt">boolean</span> <span class="nf">removeAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>        <span class="c1">//차집합</span>
<span class="n">Iterator</span> <span class="nf">iterator</span><span class="o">();</span>    <span class="c1">//Iterator을 사용하여 순회</span>
</pre></div>
</div>
<p>HashSet과 HashMap의 중복의 조건:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span> <span class="o">{</span>
</pre></div>
</div>
</div>
<div class="section" id="treeset">
<h3>1.4.9. TreeSet<a class="headerlink" href="#treeset" title="Permalink to this headline">¶</a></h3>
<p>Red-Black Tree로 구현되어 있으며 Set을 구현하였기 때문에 중복저장을 허용하지 않는 자료구조이다.</p>
<p>장점</p>
<ol class="arabic simple">
<li>탐색속도가 O(logN)으로 링크드리스트보다 빠르다.</li>
<li>삽입삭제 속도가 O(logN)으로 배열의 연산보다 평균적으로 빠른편이다.</li>
<li>필요한 만큼만 메모리를 차지한다.</li>
<li>데이터가 정렬되어 있기 때문에 범위(Range) 검색이 빠르다.</li>
</ol>
<p>단점</p>
<ol class="arabic simple">
<li>링크드리스트보단 삽입/삭제 속도가 느리다. 균형을 맞추기 위해 시간이 든다.</li>
</ol>
<p>인터페이스:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>

<span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="nf">containsAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>

<span class="n">Object</span> <span class="nf">first</span><span class="o">();</span>
<span class="n">Object</span> <span class="nf">last</span><span class="o">();</span>

<span class="n">SortedSet</span> <span class="nf">headSet</span><span class="o">(</span><span class="n">Object</span> <span class="n">toElement</span><span class="o">);</span> <span class="c1">// 이 객체보다 작은 값을 가진 집합을 반환한다.       //범위검색</span>
<span class="n">SortedSet</span> <span class="nf">tailSet</span><span class="o">(</span><span class="n">Object</span> <span class="n">from</span><span class="o">);</span> <span class="c1">// 이 객체보다 같거나 큰 값을 가진 집합을 반환한다.</span>
<span class="n">SortedSet</span> <span class="nf">subSet</span><span class="o">(</span><span class="n">Object</span> <span class="n">from</span><span class="o">,</span> <span class="n">Object</span> <span class="n">to</span><span class="o">);</span> <span class="c1">// from과 같거나 크면서 to보다 작은 결과를 반환한다.</span>

<span class="n">Iterator</span> <span class="nf">iterator</span><span class="o">();</span>    <span class="c1">//iterator를 사용하여 순회가능</span>

<span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>           <span class="c1">//합집합</span>
<span class="kt">boolean</span> <span class="nf">retainAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>        <span class="c1">//교집합</span>
<span class="kt">boolean</span> <span class="nf">removeAll</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span>        <span class="c1">//차집합</span>
</pre></div>
</div>
<p><strong>중복체크 코드는 TreeMap의 put에 관련되어 있다. 삽입하는 과정에서 같은 키가 존재하는지 찾아서 덮어 씌운다.</strong></p>
<div class="highlight-java"><div class="highlight"><pre><span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
<span class="k">else</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</pre></div>
</div>
<p>중복하지 않을 경우 그냥 삽입한다.:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">parent</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
<span class="k">else</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="comparable-comparator">
<h3>1.4.10. Comparable, Comparator<a class="headerlink" href="#comparable-comparator" title="Permalink to this headline">¶</a></h3>
<p><strong>Comparable은 비교되는 대상 내부에서 구현되어 객체를 정렬할때 사용된다. Comparator는 비교대상의 외부에서 2개의 대상을 비교하여 정렬하는 방식이다.</strong></p>
<p>Comparable:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span> <span class="c1">//비교대상 내부에서 구현될 때 To</span>
</pre></div>
</div>
<p>Comparator:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">T</span> <span class="n">obj1</span><span class="o">,</span> <span class="n">T</span> <span class="n">obj2</span><span class="o">);</span>    <span class="c1">//비교대상 외부에서 구현될 때</span>
</pre></div>
</div>
</div>
<div class="section" id="map">
<h3>1.4.11. Map<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h3>
<p>Map은 키를 이용해 값을 찾는 자료구조이다. 내부적으로 Map.Entry 타입의 키-값 쌍을 저장하고 있다.</p>
<p><strong>Map</strong> 의 중요한 특징은 키는 중복되지 않으며 값은 중복될 수 있는 것이다. 따라서 같은 키로 저장하게되면 기존의 키-값 쌍을 덮어씌운다.</p>
<p>키-값쌍은 Set형태로 반환받을 수 있다.:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">Set</span> <span class="nf">keySet</span><span class="o">();</span>   <span class="c1">//키 집합 (중복 불허)</span>
<span class="n">Set</span> <span class="nf">entrySet</span><span class="o">();</span> <span class="c1">//키-값 쌍 집합 (중복 불허)</span>
<span class="n">Collection</span> <span class="nf">values</span><span class="o">();</span>    <span class="c1">//값 집합 (중복허용)</span>

<span class="kt">boolean</span> <span class="nf">containsKey</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">);</span>        <span class="c1">//키가 존재하는지</span>
<span class="kt">boolean</span> <span class="nf">containsValue</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">);</span>      <span class="c1">//값이 존재하는지</span>
<span class="n">Object</span> <span class="nf">put</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">);</span>
<span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">);</span>
</pre></div>
</div>
<p>Map.Entry 인터페이스:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">Object</span> <span class="nf">getKey</span><span class="o">();</span>
<span class="n">Object</span> <span class="nf">getValue</span><span class="o">();</span>
<span class="n">Object</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">Object</span> <span class="n">value</span><span class="o">);</span>
</pre></div>
</div>
</div>
<div class="section" id="hashmap">
<h3>1.4.12. HashMap<a class="headerlink" href="#hashmap" title="Permalink to this headline">¶</a></h3>
<p>먼저 <a class="reference internal" href="../datastructure/data_structure.html#hash-table"><em>해시 테이블</em></a> 을 확인해보자.</p>
<p>HashSet과 HashMap의 중복의 조건:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span> <span class="o">{</span>
</pre></div>
</div>
<p><strong>HashTable은 키나 값으로 null을 허용하지 않지만 HashMap은 허용한다.</strong></p>
</div>
<div class="section" id="treemap">
<h3>1.4.13. TreeMap<a class="headerlink" href="#treemap" title="Permalink to this headline">¶</a></h3>
<p>Red-Black Tree로 구현된 이진탐색트리이다. HashMap에 비해 검색성능이 느리다. 단 데이터의 정렬이 필요하거나 범위검색에서 빠른 성능을 보인다. 기본적인 인터페이스는 HashMap과 비슷하다.</p>
<p>범위검색 인터페이스:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">SortedMap</span> <span class="nf">headMap</span><span class="o">(</span><span class="n">Object</span> <span class="n">toKey</span><span class="o">);</span>                        <span class="c1">//key보다 작은 값들, 포함하지 않는다.</span>
<span class="n">SortedMap</span> <span class="nf">tailMap</span><span class="o">(</span><span class="n">Object</span> <span class="n">fromKey</span><span class="o">);</span>                      <span class="c1">//key를 포함하여 큰 값 들</span>
<span class="n">SortedMap</span> <span class="nf">subMap</span><span class="o">(</span><span class="n">Object</span> <span class="n">toKey</span><span class="o">,</span> <span class="n">Object</span> <span class="n">fromKey</span><span class="o">);</span> <span class="c1">//from과 같거나 크면서 to 보다 작은 값 들</span>
</pre></div>
</div>
<p>SortedMap은 일반 Map인터페이스를 사용하며 정렬되어 있다.</p>
<p><strong>삽입하는 과정에서 같은 키가 존재하는지 찾아서 덮어 씌운다.</strong></p>
<div class="highlight-java"><div class="highlight"><pre><span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
<span class="k">else</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</pre></div>
</div>
<p>중복하지 않을 경우 그냥 삽입한다.:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">parent</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
<span class="k">else</span>
    <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="treemap-treeset-vs-hashmap-hashset">
<h3>1.4.14. TreeMap, TreeSet vs HashMap, HashSet<a class="headerlink" href="#treemap-treeset-vs-hashmap-hashset" title="Permalink to this headline">¶</a></h3>
<p>RB트리 기반과 해시테이블 기반으로 나눠진다.</p>
<p>두 자료구조는 큰 차이점을 가지고 있다. 각각의 장점을 가지고 있는데 RB트리는 키가 정렬이 되있고 범위 검색에 빠른 성능을 보인다는 것이다. 반대로 HashMap은 정렬 기능이 없어서 범위 검색이 불가능하지만 키값 검색 성능이 우수하다.</p>
<p>사용 예시)</p>
<ul class="simple">
<li>기본적으로 빠른 검색이 필요할 경우</li>
<li>정렬이 필요한지 없는지 판단 필요</li>
</ul>
</div>
</div>
<div class="section" id="java-nio">
<h2>1.5. Java NIO<a class="headerlink" href="#java-nio" title="Permalink to this headline">¶</a></h2>
<p>말그대로 Non-Blocking IO를 뜻한다.</p>
<p>OIO(Old I/O)의 문제점은 클라이언트마다 스레드가 할당되어 서비스를 하는 방식이여서 <strong>클라이언트 수에 비례하여 스레드 자원이 증가하는 것과</strong> 스레드가 지나치게 많아질 경우 컨텍스트 스위칭이 발생하는 등의 문제점으로 뽑힌다. 상황에 따라 다르지만 확실한 것은 NIO는 OIO에 비해 규모 확장성이 뛰어난 모델이라는 것이다.</p>
<p><strong>NIO는 Non-Blocking을 통해 Polling을 구현하도록 도와준다.</strong> Polling 방식과 Non-Blocking을 통해 1개의 스레드로 모든 소켓을 검사할 수 있다.</p>
<p><strong>NIO의 Selector를 사용하면 OS의 지원을 받아 소켓의 다양한 변화를 감지할 수 있다.</strong> Selector란 소켓을 관리하며 변화를 감지하는 역할을 한다. 이처럼 싱글 스레드를 이용해 다수의 클라이언트를 처리할 수 있는 것이 Java NIO의 장점이다. <a class="reference external" href="http://stackoverflow.com/questions/7611152/nio-performance-improvement-compared-to-traditional-io-in-java">NIO 장점</a></p>
</div>
<div class="section" id="id9">
<h2>1.6. 헷갈리는 문제<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p><strong>무엇보다 중요한건 문제를 꼼곰히 읽은 뒤 푸는것이다.</strong></p>
<ol class="arabic simple">
<li>오버라이딩시 접근제한자 변경 문제 (컴파일 에러)</li>
</ol>
<p>오버라이드 메서드에서는 부모의 접근제한자보다 같거나 넓은 범위의 접근제한자를 사용해야한다. 좁은 범위의 접근제한자를 쓰면 <strong>컴파일 에러</strong> 가 발생한다.</p>
<p><strong>protected -&gt; public (오버라이드 됨)</strong>
<strong>protected -&gt; protected (오버라이드 됨)</strong>
<strong>protected -&gt; private (오버라이드 안됨, 컴파일 에러)</strong></p>
<img alt="../_images/오버라이드접근자.png" src="../_images/오버라이드접근자.png" />
<ol class="arabic simple" start="2">
<li>오버라이딩시 예외 범위 문제 (컴파일 에러)</li>
</ol>
<p>오버라이드 메서드는 부모의 예외보다 많이 선언할 수 없다. 그리고 부모의 예외보다 부모격인 예외를 던져선 안된다.</p>
<p><strong>IOException -&gt; IOException, NullPointException (불가능, 컴파일 에러)</strong>
<strong>IOExcetpion -&gt; Exception (불가능, 컴파일 에러)</strong></p>
<img alt="../_images/오버라이드예외처리.png" src="../_images/오버라이드예외처리.png" />
<ol class="arabic simple" start="3">
<li>오버라이딩시 인스턴트 메서드를 스태틱 메서드로 바꿀 수 없다. (컴파일 에러)</li>
<li>오바리이딩시 final이 있을 경우 오버라이딩 안됨. (컴파일 에러)</li>
</ol>
<img alt="../_images/오버라이드파이날.png" src="../_images/오버라이드파이날.png" />
<ol class="arabic simple" start="5">
<li>제한자의 종류와 범위</li>
</ol>
<p><strong>static 제어자의 대상</strong></p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">멤버변수</span><span class="o">(</span><span class="n">멤버</span> <span class="n">클래스에</span> <span class="n">적용할</span> <span class="n">경우</span> <span class="n">스태틱</span> <span class="n">클래스</span> <span class="n">가능</span><span class="o">),</span> <span class="n">메서드</span>
</pre></div>
</div>
<p><strong>final의 대상</strong></p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">클래스</span> <span class="o">:</span> <span class="n">상속될</span> <span class="n">수</span> <span class="n">없는</span> <span class="n">클래스가</span> <span class="n">된다</span><span class="o">.</span> <span class="o">(</span><span class="n">컴파일</span> <span class="n">에러</span><span class="o">)</span>
<span class="n">메서드</span> <span class="o">:</span> <span class="n">메서드는</span> <span class="n">더</span> <span class="n">이상</span> <span class="n">오버라이드</span> <span class="n">될</span> <span class="n">수</span> <span class="n">없다</span><span class="o">.</span> <span class="o">(</span><span class="n">컴파일</span> <span class="n">에러</span><span class="o">)</span>
<span class="n">멤버변수</span> <span class="o">:</span> <span class="n">최초의</span> <span class="n">초기화</span> <span class="n">이후</span> <span class="n">변경되지</span> <span class="n">않음</span><span class="o">.</span> <span class="o">(</span><span class="n">변수</span> <span class="n">초기화문이</span> <span class="nf">어디에도</span><span class="o">(</span><span class="n">초기화</span> <span class="n">블록</span> <span class="n">또는</span> <span class="n">생성자</span><span class="o">)</span> <span class="n">없다면</span> <span class="n">컴파일에러</span><span class="o">,</span> <span class="n">초기화</span> <span class="n">하려고</span> <span class="n">하면</span> <span class="n">컴파일</span> <span class="n">에러</span><span class="o">)</span>
<span class="n">지역변수</span> <span class="o">:</span> <span class="n">최초의</span> <span class="n">초기화</span> <span class="n">이후</span> <span class="n">변경되지</span> <span class="n">않음</span><span class="o">.</span> <span class="o">(</span><span class="n">멤버변수와는</span> <span class="n">달리</span> <span class="n">초기화하지</span> <span class="n">않아도</span> <span class="n">컴파일</span> <span class="n">에러는</span> <span class="n">없음</span><span class="o">.</span> <span class="n">단</span><span class="o">,</span> <span class="n">지역변수와</span> <span class="n">마찬가지로</span> <span class="n">초기화</span> <span class="n">안하고</span> <span class="n">사용하려고</span> <span class="n">할</span> <span class="n">경우</span> <span class="n">컴파일</span> <span class="n">에러</span><span class="o">,</span> <span class="n">또</span> <span class="n">다시</span> <span class="n">초기화</span> <span class="n">하려고하면</span> <span class="n">컴파일</span> <span class="n">에러</span><span class="o">)</span>
</pre></div>
</div>
<p><strong>abstract</strong></p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">클래스</span> <span class="o">:</span> <span class="n">추상</span> <span class="n">메서드가</span> <span class="n">존재할</span> <span class="n">수</span> <span class="n">있음을</span> <span class="n">암시</span><span class="o">,</span> <span class="n">하지만</span> <span class="n">존재하지</span> <span class="n">않아도</span> <span class="n">에러는</span> <span class="n">발생하지</span> <span class="n">않음</span><span class="o">,</span> <span class="n">부모가</span> <span class="n">abstract가</span> <span class="n">아니더라도</span> <span class="n">추상</span> <span class="n">클래스로</span> <span class="n">바꿀</span> <span class="n">수</span> <span class="n">있음</span>
<span class="n">메서드</span> <span class="o">:</span> <span class="n">구현부가</span> <span class="n">존재하지</span> <span class="n">않는</span> <span class="n">추상</span> <span class="n">메서드임을</span> <span class="n">나타냄</span>
</pre></div>
</div>
<p><strong>접근제어자</strong></p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">접근제어자</span> <span class="n">대상</span> <span class="o">-</span> <span class="n">클래스</span><span class="o">(</span><span class="kd">public</span><span class="o">,</span> <span class="k">default</span><span class="o">)</span>
<span class="n">멤버변수</span><span class="o">,</span> <span class="n">메서드</span><span class="o">,</span> <span class="n">생성자</span><span class="o">(</span><span class="kd">public</span><span class="o">,</span> <span class="kd">protected</span><span class="o">,</span> <span class="o">(</span><span class="k">default</span><span class="o">),</span> <span class="kd">private</span><span class="o">)</span>
<span class="kd">public</span> <span class="o">-</span> <span class="n">모든</span> <span class="n">범위에서</span> <span class="n">접근할</span> <span class="n">수</span> <span class="n">있다</span><span class="o">.</span>
<span class="kd">protected</span> <span class="o">-</span> <span class="n">같은</span> <span class="n">패키지에서</span> <span class="n">접근이</span> <span class="n">되며</span> <span class="n">다른</span> <span class="n">패키지에서</span> <span class="n">상속으로</span> <span class="n">접근할</span> <span class="n">수</span> <span class="n">있다</span><span class="o">.</span>
<span class="k">default</span> <span class="o">-</span> <span class="n">같은</span> <span class="n">패키지</span> <span class="n">내에서만</span> <span class="n">접근이</span> <span class="n">가능하다</span><span class="o">.</span> <span class="o">(</span><span class="n">아무것도</span> <span class="n">쓰지</span> <span class="n">않았을</span> <span class="n">때</span><span class="o">)</span>
<span class="n">priavate</span> <span class="o">-</span> <span class="n">클래스</span> <span class="n">내에서만</span> <span class="n">사용할</span> <span class="n">수</span> <span class="n">있다</span><span class="o">.</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li>지역변수를 초기화하지 않고 사용할 경우 (컴파일에러, 하지만 단순히 초기화 안하는건 문제되지 않음)</li>
<li>생성자의 접근제한자가 private일 경우 상속할 수 없다. (따라서 싱글톤 패턴은 상속안됨)</li>
</ol>
<img alt="../_images/private상속.png" src="../_images/private상속.png" />
<ol class="arabic simple" start="8">
<li>protected 생성자는 상속을 통해 다른 패키지에서 접근할 수 있지만 인스턴스화 해서 사용할 수 없다.</li>
</ol>
<img alt="../_images/protected상속.png" src="../_images/protected상속.png" />
<ol class="arabic simple" start="9">
<li>제어자 정리</li>
</ol>
<p>정리:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">클래스</span> <span class="o">-</span> <span class="kd">public</span><span class="o">,</span> <span class="k">default</span><span class="o">,</span> <span class="kd">abstract</span><span class="o">,</span> <span class="kd">final</span>
<span class="n">메서드</span> <span class="o">-</span> <span class="kd">public</span><span class="o">,</span> <span class="kd">protected</span><span class="o">,</span> <span class="kd">private</span><span class="o">,</span> <span class="kd">final</span><span class="o">,</span> <span class="kd">abstract</span><span class="o">,</span> <span class="kd">static</span>
<span class="n">멤버변수</span> <span class="o">-</span> <span class="kd">public</span><span class="o">,</span> <span class="kd">protected</span><span class="o">,</span> <span class="kd">private</span><span class="o">,</span> <span class="kd">final</span><span class="o">,</span> <span class="kd">abstract</span><span class="o">,</span> <span class="kd">static</span>
<span class="n">지역변수</span> <span class="o">-</span> <span class="kd">final</span>
</pre></div>
</div>
<ol class="arabic simple" start="10">
<li>static에는 abstract를 사용할 수 없다. (컴파일 에러)</li>
<li>abstract와 final은 동시에 사용할 수 없다. (컴파일 에러)</li>
<li>abstract메서드의 접근 제어자가 private일 수 없다. (컴파일 에러)</li>
<li>private와 final을 같이 사용할 수 있으나 그럴 필요는 없다. (에러는 없음)</li>
<li>초기화 블록에는 클래스(static) 초기화 블록과 인스턴스 초기화 블록이 있다.</li>
</ol>
<p>클래스 초기화:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">static</span><span class="o">{</span>
        <span class="c1">//클래스 로딩과 함께 호출되는 블록</span>

<span class="o">}</span>
</pre></div>
</div>
<p>인스턴스 초기화:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="o">{</span>
        <span class="c1">//생성자 호출전에 실행되는 인스턴스 초기화 블록</span>

<span class="o">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="15">
<li>멤버변수는 선언과 함께 기본값으로 초기화 되지만 지역변수는 초기화 되지 않는다.(초기화 없이 그냥 사용(함수 호출, 산술연산 등등) 하면 컴파일 에러)</li>
</ol>
<img alt="../_images/지역변수초기화.png" src="../_images/지역변수초기화.png" />
<img alt="../_images/지역변수초기화2.png" src="../_images/지역변수초기화2.png" />
<ol class="arabic simple" start="16">
<li>boolean 사이즈는 가상머신에 의존한다. 1byte가 아니다.</li>
</ol>
<p><strong>This data type represents one bit of information, but its &#8220;size&#8221; isn&#8217;t something that&#8217;s precisely defined.</strong></p>
<ol class="arabic simple" start="17">
<li>변수의 크기가 값보다 작다면 강제 형변환을 하자.</li>
</ol>
<img alt="../_images/기본형타입.png" src="../_images/기본형타입.png" />
<ol class="arabic simple" start="18">
<li>finalize() 메서드는 호출되지 않을 수 있으므로 이 메서드에 의존 하지말자.</li>
</ol>
<p>가비지컬렉터가 실행하는 메서드이다. 가비지컬렉션은 어플리케이션 생명주기 동안 한번도 실행되지 않을 수 있다. 따라서 가비지컬렉션의 대상이 되었다고 하여 이 메서드에서 중요한 작업을 해서는 안된다.</p>
<ol class="arabic simple" start="19">
<li>int value = 9 / 0 은 Runtime 예외룰 발생 시킨다. ArithmeticException 예외가 발생함.</li>
<li>default 접근제어자를 갖는 static 변수는 자식에서 접근할 수 없지만 protected 접근제어자를 갖는 static 변수는 다른 패키지의 자식에서 접근할 수 있다. protected 생성자는 상속에 관계없이 다른 패키지에서 호출되지 않는다.(인스턴스화 되지 않음)</li>
</ol>
<p>protected static 변수는 상속의 룰이 적용되서 다른패키지에서 접근가능하다.</p>
<img alt="../_images/static.png" src="../_images/static.png" />
<img alt="../_images/static2.png" src="../_images/static2.png" />
<ol class="arabic simple" start="21">
<li>초기화된 상수에 다시 값을 할당 하려고 할때 발생하는 컴파일 에러</li>
</ol>
<img alt="../_images/상수초기화.png" src="../_images/상수초기화.png" />
<ol class="arabic simple" start="22">
<li>체크예외가 없다면 try-finally 문 역시 사용 가능하다. try문 안에 언체크 예외가 있더라도 finally는 실행된다.</li>
</ol>
<img alt="../_images/finally.png" src="../_images/finally.png" />
<img alt="../_images/finally2.png" src="../_images/finally2.png" />
<ol class="arabic simple" start="23">
<li>try-catch-finally 에서 finally는 try-catch에서 return, continue, break, 예외가 있다 하더라도 finally가 먼저 실행된 뒤 실행된다.</li>
</ol>
<img alt="../_images/finallyreturn.png" src="../_images/finallyreturn.png" />
<p>위와 같은 상황에서 콘솔에는 다음과 같이 출력되며 return은 finally다음에 실행된다.</p>
<ul class="simple">
<li>catch</li>
<li>finally</li>
<li>&#8220;return 실행&#8221;</li>
</ul>
<ol class="arabic simple" start="24">
<li>자바의 Generic은 하나의 타입이 아니고 타입 캐스팅을 판단하는 기준이다. 따라서 리플렉션이 적용되지 않는다.</li>
<li>클래스의 로딩은 로드타임 동적 로딩과 런타임 동적 로딩으로 이뤄진다. JVM의 클래스로더가 로딩할 경우 로드타임 동적 로딩, 프로그램 실행중에 로드할 경우 런타임 동적로딩이다.</li>
<li>내부 클래스에는 인스턴스 클래스, 스태틱 클래스, 지역 클래스 등이 있다. 익명 클래스는 선언과 동시에 객체를 생성할때 사용한다.</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. 자바 기본</a><ul>
<li><a class="reference internal" href="#id2">1.1. 자바 동기화 (임계영역 해결책)</a><ul>
<li><a class="reference internal" href="#notifyall-vs-notify">1.1.1. notifyAll() vs notify()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic">1.2. 자바 Generic</a><ul>
<li><a class="reference internal" href="#type-erasure">1.2.1. 타입 제거 (Type Erasure)</a></li>
<li><a class="reference internal" href="#c">1.2.2. 자바 제너릭과 C++ 템플릿과의 차이점</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">1.3. 자바의 예외</a><ul>
<li><a class="reference internal" href="#runtime-exception">1.3.1. 언체크 예외의 목적(Runtime Exception)</a></li>
<li><a class="reference internal" href="#id5">1.3.2. 체크 예외의 목적(Runtime Exception을 제외한 예외)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collection">1.4. 컬렉션 프레임워크(Collection)</a><ul>
<li><a class="reference internal" href="#list-set">1.4.1. List &amp; Set</a></li>
<li><a class="reference internal" href="#arraylist">1.4.2. ArrayList의 장/단점</a></li>
<li><a class="reference internal" href="#linkedlist">1.4.3. LinkedList의 장/단점</a></li>
<li><a class="reference internal" href="#stack-queue">1.4.4. Stack과 Queue</a></li>
<li><a class="reference internal" href="#id6">1.4.5. 동기화 보장</a></li>
<li><a class="reference internal" href="#id7">1.4.6. 얕은복사와 깊은복사</a></li>
<li><a class="reference internal" href="#id8">1.4.7. 정렬</a></li>
<li><a class="reference internal" href="#hashset">1.4.8. HashSet</a></li>
<li><a class="reference internal" href="#treeset">1.4.9. TreeSet</a></li>
<li><a class="reference internal" href="#comparable-comparator">1.4.10. Comparable, Comparator</a></li>
<li><a class="reference internal" href="#map">1.4.11. Map</a></li>
<li><a class="reference internal" href="#hashmap">1.4.12. HashMap</a></li>
<li><a class="reference internal" href="#treemap">1.4.13. TreeMap</a></li>
<li><a class="reference internal" href="#treemap-treeset-vs-hashmap-hashset">1.4.14. TreeMap, TreeSet vs HashMap, HashSet</a></li>
</ul>
</li>
<li><a class="reference internal" href="#java-nio">1.5. Java NIO</a></li>
<li><a class="reference internal" href="#id9">1.6. 헷갈리는 문제</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="java_index.html"
                        title="previous chapter">자바(JAVA)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="java_jvm.html"
                        title="next chapter">2. JVM</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/java/java_basic.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="java_jvm.html" title="2. JVM"
             >next</a> |</li>
        <li class="right" >
          <a href="java_index.html" title="자바(JAVA)"
             >previous</a> |</li>
        <li><a href="../index.html">Changchang Documentation 1.0 documentation</a> &raquo;</li>
          <li><a href="java_index.html" >자바(JAVA)</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Changwon Choe.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>